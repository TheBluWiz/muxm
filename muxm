#!/usr/bin/env bash
# =============================================================================
#  MuxMaster™ Freeware License v1.0
#  Copyright © 2025 Jamey Wicklund (theBluWiz)
# =============================================================================
# Universal DV/HLG/HDR10/SDR → MP4 (Apple TV Direct Play) Encoder
# Requires: ffmpeg, ffprobe, dovi_tool >= 2.0
# Optional (for OCR): Subtitle Edit CLI + Tesseract (SUB_ENABLE_OCR=1)
# =============================================================================

# ===== Section 1: Strict mode & debug =========================================================
# Fail fast, propagate failures across pipelines/subshells, and treat unset vars as errors.
set -eEuo pipefail
# Ensure ERR traps propagate through functions and subshells where supported.
if shopt -q inherit_errexit 2>/dev/null; then shopt -s inherit_errexit; fi
# Dev convenience: DEBUG=1 enables bash xtrace
[[ "${DEBUG:-0}" == "1" ]] && set -x

# ===== Section 2: Branding / CLI constants (locked; not configurable) =========================
readonly APP_NAME="MuxMaster"
readonly CLI_NAME="muxm"
readonly VERSION="1.4"  # 1.4: pipelines + skip flags + robust subtitle probing

# ===== Section 3: Globals =====================================================================
declare -a COMPLETED_STEPS=()
declare -a MUXM_CONFIG_LOADED=()
WORKDIR=""
LOGFILE=""
FAILED=0
FAIL_MSG=""
EXIT_CODE=1
PRINT_EFFCONF=0
CONFIG_WRITE_PROMPTED=0
CONFIG_WRITE_ROTATE=0
CONFIG_WRITE_PATH=""

# ===== Section 4: Opinionated defaults (lowest precedence) ====================================
# ---- Video encode (x265)
CRF_VALUE=18
PRESET_VALUE="slower"
X265_PARAMS_BASE='profile=main10:repeat-headers=1:hdr-opt=1:aq-mode=3:aq-strength=1.3:psy-rd=2.0:psy-rdoq=1.0:rc-lookahead=60'
LEVEL_VALUE=""                 # e.g., 5.1 (blank = encoder decides)
CONSERVATIVE_VBV=1
LEVEL_VBV_4_1_MAXRATE=10000k; LEVEL_VBV_4_1_BUFSIZE=20000k
LEVEL_VBV_5_0_MAXRATE=25000k; LEVEL_VBV_5_0_BUFSIZE=50000k
LEVEL_VBV_5_1_MAXRATE=40000k; LEVEL_VBV_5_1_BUFSIZE=80000k
LEVEL_VBV_5_2_MAXRATE=60000k; LEVEL_VBV_5_2_BUFSIZE=120000k

# ---- Pixel format / chroma policy
FORCE_CHROMA_420=1
SDR_USE_10BIT_IF_SRC_10BIT=1
HDR_TARGET_PIXFMT="yuv420p10le"

# ---- Threads
THREADS=""

# ---- Dolby Vision policy
DISABLE_DV=0
ALLOW_DV_FALLBACK=1
DV_CONVERT_TO_P81_IF_FAIL=1

# ---- Audio selection (preferences & weights)
AUDIO_LANG_PREF="eng"                 # comma-separated list
AUDIO_CODEC_PREFERENCE="eac3,ac3,aac,other"
AUDIO_SCORE_CHANNEL_MULTIPLIER=20
AUDIO_SCORE_SURROUND_BONUS=30
AUDIO_SCORE_LANG_BONUS_ENG=25

# ---- Audio transcode policy
STEREO_BITRATE="192k"
MAX_AUDIO_CHANNELS=8
ADD_STEREO_IF_MULTICH=1
EAC3_BITRATE_5_1="640k"
EAC3_BITRATE_7_1="768k"
PARALLEL_AUDIO=0

# ---- Subtitles (selection & OCR policy)
SUB_LANG_PREF="eng"            # comma list (e.g., "eng,spa")
SUB_INCLUDE_FORCED=1           # include forced track if available
SUB_INCLUDE_FULL=1             # include standard full-English if available
SUB_INCLUDE_SDH=1              # include SDH/HI by default; can be disabled via CLI
SUB_MAX_TRACKS=3               # up to Forced + Full + SDH

# OCR for PGS → SRT
SUB_ENABLE_OCR=1               # requires sub2srt + Tesseract in PATH
SUB_OCR_TOOL="sub2srt"         # we will call sub2srt on a .idx; ffmpeg makes the .idx/.sub
SUB_OCR_LANG="eng"             # language hint (sub2srt may ignore; Tesseract default is eng)

# ---- Muxing / output (container choice)
OUTPUT_EXT="mp4"               # supports mp4|m4v|mov (MP4 family)
MP4_INTERLEAVE_MS=500          # kept for config compatibility (ffmpeg-only final mux)
TAG_LANGUAGE_DEFAULT="und"
INCLUDE_AUDIO_TITLES=1

# ---- Operational defaults
CHECKSUM=0
DRY_RUN=0
KEEP_TEMP=0
KEEP_TEMP_ALWAYS=0
DISK_FREE_WARN_GB=5

# ---- ffmpeg/ffprobe UX
FFMPEG_HIDE_BANNER=1
FFMPEG_LOGLEVEL="error"   # quiet|panic|fatal|error|warning|info|verbose|debug|trace
FFMPEG_OVERWRITE=1
FFPROBE_LOGLEVEL="error"

# ---- Demux policy
ANNEXB_FOR_DEMUX=1

# ---- Quick-test toggles (NEW)
# These allow exercising parts of the pipeline quickly, without heavy compute.
SKIP_VIDEO=0    # --skip-video : skip demux/encode/DV; omit video from final mux
SKIP_AUDIO=0    # --skip-audio : skip audio selection/transcode; omit audio from final mux
SKIP_SUBS=0     # --skip-subs  : skip all subtitle prep/mapping; omit subtitles from final mux

# ===== Section 5: Basic helpers ===============================================================
say()  { printf "%s\n" "$@" >&2; }
note() { printf "ℹ️  %s\n" "$@" >&2; }
warn() { printf "⚠️  %s\n" "$@" >&2; }
die()  { local code=1; if [[ $# -gt 1 && "$1" =~ ^[0-9]+$ ]]; then code="$1"; shift; fi; FAILED=1; EXIT_CODE="$code"; FAIL_MSG="Fatal: $*"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; exit "$code"; }
on_error(){ local lineno="$1" cmd="$2" status="$3"; FAILED=1; EXIT_CODE="${EXIT_CODE:-$status}"; FAIL_MSG="Command failed at line $lineno: $cmd (exit $status)"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; }
mark_done(){ COMPLETED_STEPS+=("$1"); }
need(){ command -v "$1" >/dev/null 2>&1 || die 10 "Missing required tool: $1"; }
timestamp(){ date +"%Y-%m-%d %H:%M:%S"; }
realpath_fallback(){ if command -v realpath >/dev/null 2>/dev/null; then realpath "$1"; else echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"; fi; }
filesize_pretty(){
  if command -v gstat >/dev/null 2>/dev/null; then gstat -c "%n %s bytes" "$1"
  elif stat -f "%N %z bytes" /dev/null >/dev/null 2>&1; then stat -f "%N %z bytes" "$1"
  elif stat --printf '%n %s bytes\n' /dev/null >/dev/null 2>&1; then stat --printf '%n %s bytes\n' "$1"
  else ls -lh "$1"; fi
}
kill_if_running(){ local pid="${1:-}"; [[ -n "$pid" ]] || return 0; if kill -0 "$pid" 2>/dev/null; then kill "$pid" 2>/dev/null || true; fi; }
checksum_cmd(){ command -v sha256sum >/dev/null 2>/dev/null && { echo "sha256sum"; return; }; command -v shasum >/dev/null 2>/dev/null && { echo "shasum -a 256"; return; }; echo ""; }
write_checksum(){ local p="$1" c; c="$(checksum_cmd)"; [[ -z "$c" ]] && { warn "Checksum tool not found"; return 0; }; note "Writing checksum → ${p}.sha256"; $c "$p" > "${p}.sha256"; }

# DRY-RUN-safe copy helper
cp_or_dryrun() {
  local src="$1" dst="$2"
  if (( DRY_RUN )); then
    say "DRY-RUN: copy $src → $dst"
    # no file touching in dry-run
  else
    cp -f "$src" "$dst"
  fi
}

# ===== Section 6: Write default .muxmrc (used by --install) ===================================
_write_default_muxmrc() {
  local conf_path="$1"
  _write_template() {
    local _out="$1"
    umask 022
    cat >"$_out" <<'CONF'
# MuxMaster default .muxmrc (generated)
# Keep only the keys you want to override.
# See --print-effective-config for current values.
CONF
    chmod 0644 "$_out" || true
  }
  if [[ ! -e "$conf_path" ]]; then
    _write_template "$conf_path"
    note "Wrote default config → $conf_path"
    return 0
  fi
  say "Config already exists at: $conf_path"
  printf "Overwrite with default and back up the current file? [y/N]: " >&2
  local ans
  if ! read -r ans; then ans=""; fi
  case "$ans" in
    [Yy]|[Yy][Ee][Ss])
      local ts backup_dir backup_path
      ts="$(date +%Y%m%d-%H%M%S)"
      backup_dir="$(dirname -- "$conf_path")"
      backup_path="${backup_dir}/muxmrc.${ts}.bak"
      if cp -f "$conf_path" "$backup_path"; then
        note "Backed up current config → $backup_path"
      else
        warn "Could not back up existing config; proceeding with overwrite."
      fi
      _write_template "$conf_path"
      note "Overwrote config with updated defaults → $conf_path"
      ;;
    *)  note "Keeping existing config. No changes made." ;;
  esac
}

# ===== Section 7: Config chain: Defaults → Global → User → Project ============================
_muxm_try_source(){
  local f="$1"
  [[ -r "$f" ]] || return 0
  # shellcheck disable=SC1090
  . "$f"
  MUXM_CONFIG_LOADED+=("$f")
}
_muxm_try_source /etc/.muxmrc
_muxm_try_source "$HOME/.muxmrc"
_muxm_try_source "./.muxmrc"
if [[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]]; then
  printf "ℹ️  Loaded config: %s\n" "${MUXM_CONFIG_LOADED[*]}" >&2
fi

# ===== Section 8: CLI parsing =================================================================
USAGE_SHORT="Usage: ${CLI_NAME} [options] <source> [target.\${OUTPUT_EXT}]"
print_usage(){ cat <<EOF
Usage: ${CLI_NAME} [options] <source.mkv|mp4|m4v|mov> [target.\${OUTPUT_EXT}]

General:
  -h, --help                      Show help
  -V, --version                   Show version
      --install                   Install to ~/.bin/${CLI_NAME} and create/update default .muxmrc
      --print-effective-config    Print effective config and exit
      --config [PATH]             Write effective config to PATH (default ./.muxmrc)

Operational:
      --dry-run                   Plan and print steps without writing output
      --checksum                  Write SHA-256 next to final output
      --no-checksum               Disable checksum
  -k, --keep-temp                 Keep workdir on FAILURE
  -K, --keep-temp-always          Keep workdir on SUCCESS and FAILURE
      --disk-free-warn-gb N       Warn if output volume has less than N GB free (default ${DISK_FREE_WARN_GB})

ffmpeg/ffprobe UX:
      --ffmpeg-loglevel LVL       quiet|panic|fatal|error|warning|info|verbose|debug|trace
      --no-hide-banner            Do not hide ffmpeg banner
      --no-overwrite              Do not pass -y to ffmpeg
      --ffprobe-loglevel LVL      Log level for ffprobe (default ${FFPROBE_LOGLEVEL})

Threads:
      --threads N                 ffmpeg -threads N (empty = ffmpeg decides)

Video (x265):
  -p, --preset NAME               ultrafast..placebo (default ${PRESET_VALUE})
      --crf N                     Constant Rate Factor (default ${CRF_VALUE})
      --x265-params STR           Full x265 param string (overrides base)
  -l, --level N                   x265 level-idc (e.g., 5.1)
      --no-conservative-vbv       Disable conservative VBV for set level

Pixel format / chroma:
      --force-420                 Downsample 422/444 → 420 (default on)
      --no-force-420              Keep source chroma
      --sdr-10bit-if-src          SDR uses 10-bit if source is 10-bit (default on)
      --no-sdr-10bit-if-src       Force SDR 8-bit
      --hdr-target-pixfmt FMT     e.g., yuv420p10le (default ${HDR_TARGET_PIXFMT})

Dolby Vision:
      --no-dv                     Disable DV handling
      --allow-dv-fallback         Proceed without DV if inject/convert fails (default on)
      --no-allow-dv-fallback      Treat DV errors as fatal
      --dv-convert-p81            Attempt P7→P8.1 on inject fail (default on)
      --no-dv-convert-p81         Do not attempt conversion

Audio selection:
      --audio-track N             Select specific audio index (0-based)
      --audio-lang-pref LIST      e.g., eng,spa,und (default ${AUDIO_LANG_PREF})
      --audio-codec-pref LIST     e.g., eac3,ac3,aac,other (default ${AUDIO_CODEC_PREFERENCE})
      --audio-score-chan-mul N    Weight for channels (default ${AUDIO_SCORE_CHANNEL_MULTIPLIER})
      --audio-score-surround N    Bonus if ch>=6 (default ${AUDIO_SCORE_SURROUND_BONUS})
      --audio-score-lang N        Language bonus (default ${AUDIO_SCORE_LANG_BONUS_ENG})
  -j, --parallelize               Encode audio tasks in parallel

Audio transcode:
      --stereo-bitrate RATE       AAC stereo bitrate (default ${STEREO_BITRATE})
      --max-audio-channels N      Cap output channels (default ${MAX_AUDIO_CHANNELS})
      --stereo-fallback           Add AAC stereo when primary >2ch (default on)
      --no-stereo-fallback        Disable AAC stereo add
      --eac3-bitrate-5-1 RATE     Default ${EAC3_BITRATE_5_1}
      --eac3-bitrate-7-1 RATE     Default ${EAC3_BITRATE_7_1}

Subtitles:
      --no-subtitles              Disable all subtitle processing
      --sub-lang-pref LIST        Preferred subtitle languages (default ${SUB_LANG_PREF})
      --no-sub-sdh                Exclude SDH/HI tracks even if present
      --ocr-lang CODE             OCR language for PGS→SRT (default ${SUB_OCR_LANG})
      --no-ocr                    Disable OCR (PGS will be skipped)
      --ocr-tool CMD              OCR tool command (default ${SUB_OCR_TOOL}; expected: sub2srt)

Quick testing (NEW):
      --skip-video                Skip video demux/encode/DV and omit video from final mux
      --skip-audio                Skip audio selection/transcode and omit audio from final mux
      --skip-subs                 Skip subtitle planning/mapping and omit subtitles from final mux

Mux / output:
      --output-ext EXT            mp4|m4v|mov (default ${OUTPUT_EXT})
EOF
}

print_version(){ echo "${APP_NAME} v${VERSION} (${CLI_NAME})"; }
is_valid_preset(){ case "$1" in ultrafast|superfast|veryfast|faster|fast|medium|slow|slower|veryslow|placebo) return 0;; *) return 1;; esac; }

POSITIONALS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) print_usage; exit 0 ;;
    -V|--version) print_version; exit 0 ;;
    --install)
      do_install(){
        local INSTALL_DIR target self
        INSTALL_DIR="$HOME/.bin"
        target="$INSTALL_DIR/${CLI_NAME}"
        self="$(realpath_fallback "$0")"
        mkdir -p "$INSTALL_DIR"
        if [[ -e "$target" && "$self" -ef "$target" ]]; then
          warn "Already installed: $target points to this script. Skipping copy."
        else
          if cp -f "$self" "$target"; then
            chmod +x "$target" || true
            note "Installed: $target"
          else
            die 11 "Failed to install to: $target"
          fi
        fi
        local conf_path
        if [[ "$EUID" -eq 0 ]]; then conf_path="/etc/.muxmrc"; else conf_path="$HOME/.muxmrc"; fi
        _write_default_muxmrc "$conf_path"
        exit 0
      }
      do_install
      ;;
    --print-effective-config) PRINT_EFFCONF=1; shift ;;
    --config)
      if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then CONFIG_WRITE_PATH="$2"; shift 2; else CONFIG_WRITE_PATH="./.muxmrc"; shift; fi
      CONFIG_WRITE_ROTATE=1 ;;

    --dry-run) DRY_RUN=1; shift ;;
    --checksum) CHECKSUM=1; shift ;;
    --no-checksum) CHECKSUM=0; shift ;;
    -k|--keep-temp) KEEP_TEMP=1; shift ;;
    -K|--keep-temp-always) KEEP_TEMP_ALWAYS=1; shift ;;
    --disk-free-warn-gb) DISK_FREE_WARN_GB="${2:-}"; shift 2 ;;

    --ffmpeg-loglevel) FFMPEG_LOGLEVEL="${2:-}"; shift 2 ;;
    --no-hide-banner) FFMPEG_HIDE_BANNER=0; shift ;;
    --no-overwrite) FFMPEG_OVERWRITE=0; shift ;;
    --ffprobe-loglevel) FFPROBE_LOGLEVEL="${2:-}"; shift 2 ;;

    --threads) THREADS="${2:-}"; shift 2 ;;

    -p|--preset) PRESET_VALUE="${2:-}"; is_valid_preset "$PRESET_VALUE" || die 11 "Invalid preset: $PRESET_VALUE"; shift 2 ;;
    --crf) CRF_VALUE="${2:-}"; shift 2 ;;
    --x265-params) X265_PARAMS_BASE="${2:-}"; shift 2 ;;
    -l|--level) LEVEL_VALUE="${2:-}"; shift 2 ;;
    --no-conservative-vbv) CONSERVATIVE_VBV=0; shift ;;

    --force-420) FORCE_CHROMA_420=1; shift ;;
    --no-force-420) FORCE_CHROMA_420=0; shift ;;
    --sdr-10bit-if-src) SDR_USE_10BIT_IF_SRC_10BIT=1; shift ;;
    --no-sdr-10bit-if-src) SDR_USE_10BIT_IF_SRC_10BIT=0; shift ;;
    --hdr-target-pixfmt) HDR_TARGET_PIXFMT="${2:-}"; shift 2 ;;

    --no-dv) DISABLE_DV=1; shift ;;
    --allow-dv-fallback) ALLOW_DV_FALLBACK=1; shift ;;
    --no-allow-dv-fallback) ALLOW_DV_FALLBACK=0; shift ;;
    --dv-convert-p81) DV_CONVERT_TO_P81_IF_FAIL=1; shift ;;
    --no-dv-convert-p81) DV_CONVERT_TO_P81_IF_FAIL=0; shift ;;

    --audio-track) AUDIO_TRACK_OVERRIDE="${2:-}"; shift 2 ;;
    --audio-lang-pref) AUDIO_LANG_PREF="${2:-}"; shift 2 ;;
    --audio-codec-pref) AUDIO_CODEC_PREFERENCE="${2:-}"; shift 2 ;;
    --audio-score-chan-mul) AUDIO_SCORE_CHANNEL_MULTIPLIER="${2:-}"; shift 2 ;;
    --audio-score-surround) AUDIO_SCORE_SURROUND_BONUS="${2:-}"; shift 2 ;;
    --audio-score-lang) AUDIO_SCORE_LANG_BONUS_ENG="${2:-}"; shift 2 ;;
    -j|--parallelize) PARALLEL_AUDIO=1; shift ;;

    --stereo-bitrate) STEREO_BITRATE="${2:-}"; shift 2 ;;
    --max-audio-channels) MAX_AUDIO_CHANNELS="${2:-}"; shift 2 ;;
    --stereo-fallback) ADD_STEREO_IF_MULTICH=1; shift ;;
    --no-stereo-fallback) ADD_STEREO_IF_MULTICH=0; shift ;;
    --eac3-bitrate-5-1) EAC3_BITRATE_5_1="${2:-}"; shift 2 ;;
    --eac3-bitrate-7-1) EAC3_BITRATE_7_1="${2:-}"; shift 2 ;;

    --no-subtitles) SUB_INCLUDE_FORCED=0; SUB_INCLUDE_FULL=0; SUB_INCLUDE_SDH=0; shift ;;
    --sub-lang-pref) SUB_LANG_PREF="${2:-}"; shift 2 ;;
    --no-sub-sdh) SUB_INCLUDE_SDH=0; shift ;;
    --ocr-lang) SUB_OCR_LANG="${2:-}"; shift 2 ;;
    --no-ocr) SUB_ENABLE_OCR=0; shift ;;
    --ocr-tool) SUB_OCR_TOOL="${2:-}"; shift 2 ;;

    # NEW quick-test flags
    --skip-video) SKIP_VIDEO=1; shift ;;
    --skip-audio) SKIP_AUDIO=1; shift ;;
    --skip-subs)  SKIP_SUBS=1;  shift ;;

    --output-ext) OUTPUT_EXT="${2:-}"; shift 2 ;;

    --) shift; break ;;
    -*) die 11 "Unknown option: $1. $USAGE_SHORT" ;;
    *) POSITIONALS+=("$1"); shift ;;
  esac
done

# ===== Section 9: Effective config printer ====================================================
print_effective_config() {
  echo "=== ${APP_NAME} v${VERSION} — Effective Config ==="
  if [[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]]; then
    echo "Loaded config layers: ${MUXM_CONFIG_LOADED[*]}"
  else
    echo "Loaded config layers: (none)"
  fi
  cat <<EOC
# Precedence: Defaults → /etc/.muxmrc → ~/.muxmrc → ./.muxmrc → CLI flags

# Video
CRF_VALUE=${CRF_VALUE}
PRESET_VALUE=${PRESET_VALUE}
X265_PARAMS_BASE=${X265_PARAMS_BASE}
LEVEL_VALUE=${LEVEL_VALUE}
CONSERVATIVE_VBV=${CONSERVATIVE_VBV}
LEVEL_VBV_4_1_MAXRATE=${LEVEL_VBV_4_1_MAXRATE}
LEVEL_VBV_4_1_BUFSIZE=${LEVEL_VBV_4_1_BUFSIZE}
LEVEL_VBV_5_0_MAXRATE=${LEVEL_VBV_5_0_MAXRATE}
LEVEL_VBV_5_0_BUFSIZE=${LEVEL_VBV_5_0_BUFSIZE}
LEVEL_VBV_5_1_MAXRATE=${LEVEL_VBV_5_1_MAXRATE}
LEVEL_VBV_5_1_BUFSIZE=${LEVEL_VBV_5_1_BUFSIZE}
LEVEL_VBV_5_2_MAXRATE=${LEVEL_VBV_5_2_MAXRATE}
LEVEL_VBV_5_2_BUFSIZE=${LEVEL_VBV_5_2_BUFSIZE}

# Pixel/Chroma
FORCE_CHROMA_420=${FORCE_CHROMA_420}
SDR_USE_10BIT_IF_SRC_10BIT=${SDR_USE_10BIT_IF_SRC_10BIT}
HDR_TARGET_PIXFMT=${HDR_TARGET_PIXFMT}

# Threads
THREADS=${THREADS}

# Dolby Vision
DISABLE_DV=${DISABLE_DV}
ALLOW_DV_FALLBACK=${ALLOW_DV_FALLBACK}
DV_CONVERT_TO_P81_IF_FAIL=${DV_CONVERT_TO_P81_IF_FAIL}

# Audio selection
AUDIO_LANG_PREF=${AUDIO_LANG_PREF}
AUDIO_CODEC_PREFERENCE=${AUDIO_CODEC_PREFERENCE}
AUDIO_SCORE_CHANNEL_MULTIPLIER=${AUDIO_SCORE_CHANNEL_MULTIPLIER}
AUDIO_SCORE_SURROUND_BONUS=${AUDIO_SCORE_SURROUND_BONUS}
AUDIO_SCORE_LANG_BONUS_ENG=${AUDIO_SCORE_LANG_BONUS_ENG}

# Audio transcode
STEREO_BITRATE=${STEREO_BITRATE}
MAX_AUDIO_CHANNELS=${MAX_AUDIO_CHANNELS}
ADD_STEREO_IF_MULTICH=${ADD_STEREO_IF_MULTICH}
EAC3_BITRATE_5_1=${EAC3_BITRATE_5_1}
EAC3_BITRATE_7_1=${EAC3_BITRATE_7_1}
PARALLEL_AUDIO=${PARALLEL_AUDIO}

# Subtitles
SUB_LANG_PREF=${SUB_LANG_PREF}
SUB_INCLUDE_FORCED=${SUB_INCLUDE_FORCED}
SUB_INCLUDE_FULL=${SUB_INCLUDE_FULL}
SUB_INCLUDE_SDH=${SUB_INCLUDE_SDH}
SUB_MAX_TRACKS=${SUB_MAX_TRACKS}
SUB_ENABLE_OCR=${SUB_ENABLE_OCR}
SUB_OCR_TOOL=${SUB_OCR_TOOL}
SUB_OCR_LANG=${SUB_OCR_LANG}

# Mux / output
OUTPUT_EXT=${OUTPUT_EXT}
MP4_INTERLEAVE_MS=${MP4_INTERLEAVE_MS}
TAG_LANGUAGE_DEFAULT=${TAG_LANGUAGE_DEFAULT}
INCLUDE_AUDIO_TITLES=${INCLUDE_AUDIO_TITLES}

# Operational
CHECKSUM=${CHECKSUM}
DRY_RUN=${DRY_RUN}
KEEP_TEMP=${KEEP_TEMP}
KEEP_TEMP_ALWAYS=${KEEP_TEMP_ALWAYS}
DISK_FREE_WARN_GB=${DISK_FREE_WARN_GB}

# ffmpeg/ffprobe UX
FFMPEG_HIDE_BANNER=${FFMPEG_HIDE_BANNER}
FFMPEG_LOGLEVEL=${FFMPEG_LOGLEVEL}
FFMPEG_OVERWRITE=${FFMPEG_OVERWRITE}
FFPROBE_LOGLEVEL=${FFPROBE_LOGLEVEL}

# Demux
ANNEXB_FOR_DEMUX=${ANNEXB_FOR_DEMUX}

# Quick test toggles (NEW)
SKIP_VIDEO=${SKIP_VIDEO}
SKIP_AUDIO=${SKIP_AUDIO}
SKIP_SUBS=${SKIP_SUBS}
EOC
}

# ===== Section 10: Write current effective config to a .muxmrc =================================
write_effective_muxmrc() {
  local out="$1" ts dir name rotated
  ts="$(date +%Y%m%d-%H%M%S)"; dir="$(dirname -- "$out")"; name="$(basename -- "$out")"
  umask 022

  if [[ -e "$out" ]]; then
    if [[ "$name" == .* ]]; then rotated="${dir}/.effective-${ts}.${name#.}"; else rotated="${dir}/effective-${ts}.${name}"; fi
    if mv -f -- "$out" "$rotated"; then note "Existing config moved → $rotated"; else warn "Could not move existing config; continuing."; fi
  fi

  cat >"$out" <<EORC
# =============================================================================
#  MuxMaster .muxmrc — generated $(date)
# =============================================================================

# ------- Video -------
CRF_VALUE=${CRF_VALUE}
PRESET_VALUE=${PRESET_VALUE}
X265_PARAMS_BASE=${X265_PARAMS_BASE}
LEVEL_VALUE=${LEVEL_VALUE}
CONSERVATIVE_VBV=${CONSERVATIVE_VBV}
LEVEL_VBV_4_1_MAXRATE=${LEVEL_VBV_4_1_MAXRATE}
LEVEL_VBV_4_1_BUFSIZE=${LEVEL_VBV_4_1_BUFSIZE}
LEVEL_VBV_5_0_MAXRATE=${LEVEL_VBV_5_0_MAXRATE}
LEVEL_VBV_5_0_BUFSIZE=${LEVEL_VBV_5_0_BUFSIZE}
LEVEL_VBV_5_1_MAXRATE=${LEVEL_VBV_5_1_MAXRATE}
LEVEL_VBV_5_1_BUFSIZE=${LEVEL_VBV_5_1_BUFSIZE}
LEVEL_VBV_5_2_MAXRATE=${LEVEL_VBV_5_2_MAXRATE}
LEVEL_VBV_5_2_BUFSIZE=${LEVEL_VBV_5_2_BUFSIZE}

# ------- Pixel/Chroma -------
FORCE_CHROMA_420=${FORCE_CHROMA_420}
SDR_USE_10BIT_IF_SRC_10BIT=${SDR_USE_10BIT_IF_SRC_10BIT}
HDR_TARGET_PIXFMT=${HDR_TARGET_PIXFMT}

# ------- Threads -------
THREADS=${THREADS}

# ------- Dolby Vision -------
DISABLE_DV=${DISABLE_DV}
ALLOW_DV_FALLBACK=${ALLOW_DV_FALLBACK}
DV_CONVERT_TO_P81_IF_FAIL=${DV_CONVERT_TO_P81_IF_FAIL}

# ------- Audio selection -------
AUDIO_LANG_PREF=${AUDIO_LANG_PREF}
AUDIO_CODEC_PREFERENCE=${AUDIO_CODEC_PREFERENCE}
AUDIO_SCORE_CHANNEL_MULTIPLIER=${AUDIO_SCORE_CHANNEL_MULTIPLIER}
AUDIO_SCORE_SURROUND_BONUS=${AUDIO_SCORE_SURROUND_BONUS}
AUDIO_SCORE_LANG_BONUS_ENG=${AUDIO_SCORE_LANG_BONUS_ENG}

# ------- Audio transcode -------
STEREO_BITRATE=${STEREO_BITRATE}
MAX_AUDIO_CHANNELS=${MAX_AUDIO_CHANNELS}
ADD_STEREO_IF_MULTICH=${ADD_STEREO_IF_MULTICH}
EAC3_BITRATE_5_1=${EAC3_BITRATE_5_1}
EAC3_BITRATE_7_1=${EAC3_BITRATE_7_1}
PARALLEL_AUDIO=${PARALLEL_AUDIO}

# ------- Subtitles -------
SUB_LANG_PREF=${SUB_LANG_PREF}
SUB_INCLUDE_FORCED=${SUB_INCLUDE_FORCED}
SUB_INCLUDE_FULL=${SUB_INCLUDE_FULL}
SUB_INCLUDE_SDH=${SUB_INCLUDE_SDH}
SUB_MAX_TRACKS=${SUB_MAX_TRACKS}
SUB_ENABLE_OCR=${SUB_ENABLE_OCR}
SUB_OCR_TOOL=${SUB_OCR_TOOL}
SUB_OCR_LANG=${SUB_OCR_LANG}

# ------- Mux / output -------
OUTPUT_EXT=${OUTPUT_EXT}
MP4_INTERLEAVE_MS=${MP4_INTERLEAVE_MS}
TAG_LANGUAGE_DEFAULT=${TAG_LANGUAGE_DEFAULT}
INCLUDE_AUDIO_TITLES=${INCLUDE_AUDIO_TITLES}

# ------- Operational -------
CHECKSUM=${CHECKSUM}
DRY_RUN=${DRY_RUN}
KEEP_TEMP=${KEEP_TEMP}
KEEP_TEMP_ALWAYS=${KEEP_TEMP_ALWAYS}
DISK_FREE_WARN_GB=${DISK_FREE_WARN_GB}

# ------- ffmpeg/ffprobe UX -------
FFMPEG_HIDE_BANNER=${FFMPEG_HIDE_BANNER}
FFMPEG_LOGLEVEL=${FFMPEG_LOGLEVEL}
FFMPEG_OVERWRITE=${FFMPEG_OVERWRITE}
FFPROBE_LOGLEVEL=${FFPROBE_LOGLEVEL}

# ------- Demux policy -------
ANNEXB_FOR_DEMUX=${ANNEXB_FOR_DEMUX}

# ------- Quick-test toggles (NEW) -------
SKIP_VIDEO=${SKIP_VIDEO}
SKIP_AUDIO=${SKIP_AUDIO}
SKIP_SUBS=${SKIP_SUBS}
EORC

  chmod 0644 "$out" || true
  note "Wrote effective config → $out"
}

# ===== Section 11: Config write orchestration (same behavior) =================================
_write_effective_muxmrc_prompted() {
  local conf_path="$1"
  if [[ ! -e "$conf_path" ]]; then write_effective_muxmrc "$conf_path"; return 0; fi
  say "Config already exists at: $conf_path"
  printf "Overwrite with effective config and back up the current file? [y/N]: " >&2
  local ans; if ! read -r ans; then ans=""; fi
  case "$ans" in
    [Yy]|[Yy][Ee][Ss])
      local ts backup_dir backup_path
      ts="$(date +%Y%m%d-%H%M%S)"
      backup_dir="$(dirname -- "$conf_path")"
      backup_path="${backup_dir}/muxmrc.${ts}.bak"
      if cp -f -- "$conf_path" "$backup_path"; then
        note "Backed up current config → $backup_path"
      else
        warn "Could not back up existing config; proceeding."
      fi
      write_effective_muxmrc "$conf_path"
      note "Overwrote config with effective values → $conf_path"
      ;;
    *)  note "Keeping existing config. No changes made." ;;
  esac
}

# ===== Section 12: Early exits for config commands ============================================
if (( CONFIG_WRITE_PROMPTED )); then _write_effective_muxmrc_prompted "$CONFIG_WRITE_PATH"; exit 0; fi
if (( PRINT_EFFCONF )); then print_effective_config; exit 0; fi
if (( CONFIG_WRITE_ROTATE )); then write_effective_muxmrc "$CONFIG_WRITE_PATH"; exit 0; fi

# ===== Section 13: Required tools =============================================================
need ffmpeg
need ffprobe
need dovi_tool

# Subtitle OCR (optional): if enabled but tool not present, we’ll disable gracefully.
if (( SUB_ENABLE_OCR )); then
  if ! command -v "$SUB_OCR_TOOL" >/dev/null 2>&1; then
    warn "SUB_ENABLE_OCR=1 but '${SUB_OCR_TOOL}' not found in PATH — PGS OCR will be skipped."
    SUB_ENABLE_OCR=0
  fi
fi

# ===== Section 14: Inputs (SRC/OUT resolve) ===================================================
FFMPEG_FLAGS=()
FFPROBE_FLAGS=()

SRC="${POSITIONALS[0]:-}"
OUT="${POSITIONALS[1]:-}"
(( ${#POSITIONALS[@]} > 2 )) && die 11 "Too many arguments. $USAGE_SHORT"
[[ -z "$SRC" ]] && { print_usage; exit 0; }
SRC_ABS="$(realpath_fallback "$SRC")"; [[ -f "$SRC_ABS" ]] || die 11 "Source not found: $SRC_ABS"

# Default OUT with overridable extension, unless explicitly provided
if [[ -z ${OUT-} ]]; then
  base="${SRC_ABS%.*}"
  OUT="${base}.${OUTPUT_EXT}"
fi
OUT_DIR="$(dirname -- "$OUT")"
OUT_DIR="$(cd -- "$OUT_DIR" 2>/dev/null && pwd || echo "$OUT_DIR")"
OUT_BASENAME="$(basename -- "$OUT")"
OUT_ABS="${OUT_DIR}/${OUT_BASENAME}"
OUT="$OUT_ABS"
TMP_OUT="${OUT}.tmp"

# Decide container muxer from OUTPUT_EXT
MUX_FORMAT="mp4"
case "$OUTPUT_EXT" in
  mp4|m4v) MUX_FORMAT="mp4" ;;
  mov)     MUX_FORMAT="mov" ;;
  *) die 11 "Unsupported OUTPUT_EXT: $OUTPUT_EXT (use mp4|m4v|mov)";;
esac

# ===== Section 15: Build ffmpeg/ffprobe flags =================================================
# Build ffmpeg/ffprobe flag sets once; they’re appended everywhere we invoke the tools.
(( FFMPEG_HIDE_BANNER )) && FFMPEG_FLAGS+=(-hide_banner)
FFMPEG_FLAGS+=(-loglevel "$FFMPEG_LOGLEVEL")
(( FFMPEG_OVERWRITE )) && FFMPEG_FLAGS+=(-y)
FFPROBE_FLAGS=(-v "$FFPROBE_LOGLEVEL")

# NEW: Aggressive probe buffers to stabilize stream/metadata detection (esp. subs).
PROBE_OPTS=(-analyzeduration 100M -probesize 100M)
FFMPEG_FLAGS+=("${PROBE_OPTS[@]}")
FFPROBE_FLAGS+=("${PROBE_OPTS[@]}")

# ===== Section 16: Workdir (created under output directory) ===================================
# We place temp files alongside the final output for faster moves and easier inspection.
WORKDIR="$(
  TMPDIR="$OUT_DIR" mktemp -d ".muxm.tmp.XXXXXXXX"
)" || die 11 "Cannot create working directory under: $OUT_DIR"
LOGFILE="$WORKDIR/muxm.$(date +%Y%m%d-%H%M%S).log"

# ===== Section 17: Begin logging to file (tee to console) =====================================
# Default: tee both stdout/stderr to a logfile. In DEBUG=1, print directly (no file redirection).
if [[ "${DEBUG:-0}" != "1" ]]; then
  exec > >(tee -a "$LOGFILE") 2>&1
  note "Logging to $(realpath_fallback "$LOGFILE")"
fi

# ===== Section 18: Traps (ERR/INT/TERM/EXIT) & on_exit =======================================
# Keep behavior identical to your original script unless you later opt into QoL changes.
trap 'on_error $LINENO "$BASH_COMMAND" "$?"' ERR
trap 'FAILED=1; EXIT_CODE=130; FAIL_MSG="Interrupted by user (SIGINT)"; exit 130' INT
trap 'FAILED=1; EXIT_CODE=143; FAIL_MSG="Terminated (SIGTERM)"; exit 143' TERM

on_exit() {
  local have_result=0
  if (( DRY_RUN )); then
    have_result=1
  elif [[ -n "${TMP_OUT:-}" && -s "$TMP_OUT" ]]; then
    have_result=1
  elif [[ -n "${OUT:-}" && -s "$OUT" ]]; then
    have_result=1
  fi

  if (( FAILED == 0 && have_result == 1 )); then
    if (( DRY_RUN )); then
      note "DRY-RUN complete — no files were created."
    else
      [[ -f "$TMP_OUT" ]] && mv -f "$TMP_OUT" "$OUT"
      (( CHECKSUM )) && write_checksum "$OUT"
      note "Build SUCCEEDED."
    fi
    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi
    local _suffix=""
    (( DRY_RUN )) && _suffix=".dryrun"
    { echo "Completed: $(timestamp)"; printf "%s\n" "${COMPLETED_STEPS[@]:-}"; } \
      > "${OUT_DIR}/$(basename "${OUT}")${_suffix}.log" 2>/dev/null || true

    # Cleanup policy: same as your original (keep always if KEEP_TEMP_ALWAYS=1 or DEBUG=1)
    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping workdir: $WORKDIR"
    fi
    exit 0
  else
    [[ -z "$FAIL_MSG" ]] && FAIL_MSG="No output produced (likely earlier parse/runtime error)."
    printf "❌ Build FAILED. %s\n" "$FAIL_MSG"
    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi
    echo "See log: $LOGFILE"
    # Failure cleanup: keep temp if -k/--keep-temp or -K/--keep-temp-always, or DEBUG=1
    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP -eq 0 && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping failure artifacts at: $WORKDIR"
    fi
    exit "${EXIT_CODE:-1}"
  fi
}
trap 'on_exit' EXIT

# ===== Section 19: Disk space preflight =======================================================
disk_free_warn() {
  local avail_kb
  avail_kb="$(df -k "$OUT_DIR" 2>/dev/null | awk 'NR==2{print $4}')"
  if [[ -n "$avail_kb" ]] && (( avail_kb < DISK_FREE_WARN_GB*1024*1024 )); then
    warn "Less than ~${DISK_FREE_WARN_GB}GB free on output volume ($OUT_DIR). Encode may fail."
  fi
}
disk_free_warn

# ===== Section 20: (Banner moved to main()) ===================================================
# NOTE: The human-readable banner that prints input/output/presets will be emitted from main().

# ===== Section 21: ffprobe helpers ============================================================
# These helpers are robust (quiet, first-line only) and won’t trip -e on benign cases.
_probe_field(){
  # $1=field list for -show_entries stream=..., $2=file
  ffprobe "${FFPROBE_FLAGS[@]}" -show_entries "stream=$1" \
          -of default=nk=1:nw=1 "$2" 2>/dev/null | head -n1 || true
}

_has_stream(){
  # $1=file, $2=codec_type: audio|video|subtitle|data
  local types
  types="$(ffprobe "${FFPROBE_FLAGS[@]}" -show_entries stream=codec_type \
           -of default=nk=1:nw=1 "$1" 2>/dev/null || true)"
  printf '%s\n' "$types" | awk -v want="$2" 'BEGIN{IGNORECASE=1} $0==want{found=1} END{exit !found}'
}

_vcodec_name(){
  ffprobe "${FFPROBE_FLAGS[@]}" -select_streams v:0 \
          -show_entries stream=codec_name -of default=nk=1:nw=1 "$1" 2>/dev/null \
    | head -n1 | tr '[:upper:]' '[:lower:]' || true
}

# ===== Section 22: Color space & pixel format decision ========================================
IS_DV=0
PROFILE_DESC="SDR"
TARGET_PIXFMT="yuv420p"
COLOR_ARGS=()

decide_color_and_pixfmt() {
  local src="$1" pix prim trc cspace
  pix="$(_probe_field pix_fmt "$src")"
  prim="$(_probe_field color_primaries "$src")"
  trc="$(_probe_field color_transfer "$src")"
  cspace="$(_probe_field color_space "$src")"

  prim="$(printf %s "$prim"   | tr '[:upper:]' '[:lower:]')"
  trc="$(printf %s "$trc"     | tr '[:upper:]' '[:lower:]')"
  cspace="$(printf %s "$cspace"| tr '[:upper:]' '[:lower:]')"
  pix="$(printf %s "$pix"     | tr '[:upper:]' '[:lower:]')"

  local is_10bit=0 chroma="420"
  [[ "$pix" =~ p10 ]] && is_10bit=1
  [[ "$pix" =~ 422 ]] && chroma="422"
  [[ "$pix" =~ 444 ]] && chroma="444"

  if (( FORCE_CHROMA_420 )) && [[ "$chroma" != "420" ]]; then
    warn "Source chroma is 4:${chroma}; downsampling to 4:2:0 for Apple TV Direct Play."
    chroma="420"
  fi

  local tgt_pix="yuv420p" profile="SDR"
  if [[ "$trc" == "arib-std-b67" || "$trc" == "hlg" ]]; then
    profile="HLG"; tgt_pix="$HDR_TARGET_PIXFMT"; COLOR_ARGS=(-color_primaries bt2020 -color_trc arib-std-b67 -colorspace bt2020nc)
  elif [[ "$prim" == "bt2020" || "$cspace" == "bt2020nc" || "$trc" == "smpte2084" ]]; then
    profile="HDR10"; tgt_pix="$HDR_TARGET_PIXFMT"; COLOR_ARGS=(-color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc)
  else
    profile="SDR"
    if (( SDR_USE_10BIT_IF_SRC_10BIT )) && (( is_10bit )); then tgt_pix=yuv420p10le; else tgt_pix=yuv420p; fi
    [[ -z "$prim" ]] && prim="bt709"; [[ -z "$trc" ]] && trc="bt709"; [[ -z "$cspace" ]] && cspace="bt709"
    COLOR_ARGS=(-color_primaries "$prim" -color_trc "$trc" -colorspace "$cspace")
  fi
  PROFILE_DESC="$profile"; TARGET_PIXFMT="$tgt_pix"
}
# Decide immediately based on source metadata (safe; no heavy work)
decide_color_and_pixfmt "$SRC_ABS"

# ===== Section 23: x265 params & Level/VBV guardrails =========================================
X265_PARAMS="$X265_PARAMS_BASE"

# If we're not HDR10, ensure hdr-opt is NOT present (covers HLG and SDR).
if [[ "$PROFILE_DESC" != "HDR10" ]]; then
  X265_PARAMS="${X265_PARAMS/:hdr-opt=1/}"
fi

# If HDR10, enable HDR10 signaling and set x265's colorimetry.
if [[ "$PROFILE_DESC" == "HDR10" ]]; then
  X265_PARAMS="${X265_PARAMS}:hdr10=1:hdr10-opt=1:colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:range=limited"
fi

apply_level_vbv() {
  local lvl="$1" maxrate="" bufsize=""
  if (( CONSERVATIVE_VBV )); then
    case "$lvl" in
      4.1) maxrate="$LEVEL_VBV_4_1_MAXRATE"; bufsize="$LEVEL_VBV_4_1_BUFSIZE" ;;
      5.0) maxrate="$LEVEL_VBV_5_0_MAXRATE"; bufsize="$LEVEL_VBV_5_0_BUFSIZE" ;;
      5.1) maxrate="$LEVEL_VBV_5_1_MAXRATE"; bufsize="$LEVEL_VBV_5_1_BUFSIZE" ;;
      5.2) maxrate="$LEVEL_VBV_5_2_MAXRATE"; bufsize="$LEVEL_VBV_5_2_BUFSIZE" ;;
    esac
  fi
  if [[ -n "$maxrate" ]]; then
    X265_PARAMS="${X265_PARAMS}:level-idc=${lvl}:vbv-maxrate=${maxrate}:vbv-bufsize=${bufsize}"
    note "Applying VBV guardrails for level ${lvl} → maxrate=${maxrate}, bufsize=${bufsize}"
  else
    [[ -n "$lvl" ]] && X265_PARAMS="${X265_PARAMS}:level-idc=${lvl}"
  fi
}
[[ -n "$LEVEL_VALUE" ]] && apply_level_vbv "$LEVEL_VALUE"

# ===== Section 24: Dolby Vision detection (lightweight) =======================================
detect_dv() {
  (( DISABLE_DV )) && return 1
  # Fast stream tag check
  if ffprobe "${FFPROBE_FLAGS[@]}" -show_streams -select_streams v:0 "$SRC_ABS" 2>/dev/null \
      | grep -m1 -qiE 'dolby_vision|dv_profile|dovi|dvhe|dvh1|com\.dolby\.vision'; then
    return 0
  fi
  # Lightweight frame scan (first few frames)
  ffprobe "${FFPROBE_FLAGS[@]}" -show_frames -read_intervals %+#5 -select_streams v:0 "$SRC_ABS" 2>/dev/null \
    | grep -m1 -qiE 'DOVI|dolby' && return 0
  return 1
}
IS_DV=0
if detect_dv; then
  IS_DV=1
  note "Dolby Vision detected — extraction/injection will be attempted in the video pipeline."
else
  note "No Dolby Vision detected."
fi
(( DISABLE_DV )) && note "DV handling explicitly disabled via --no-dv."

# ===== Section 25: Audio selection utilities ==================================================
# Robust helpers that cope with odd metadata under -eEuo pipefail.

_audio_count() {
  local n
  n="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a \
        -show_entries stream=index -of csv=p=0 "$SRC_ABS" 2>/dev/null | wc -l | tr -d '[:space:]')"
  [[ -n "$n" ]] || n=0
  echo "$n"
}

list_audio_indices(){
  local n i
  n="$(_audio_count)"
  for (( i=0; i<n; i++ )); do echo "$i"; done
}

_ap_audio_field() { # $1=idx, $2=field
  local out=""
  out="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "a:$1" \
         -show_entries "stream=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null || true)"
  printf '%s\n' "${out%%$'\n'*}"
}
_ap_audio_tag() {   # $1=idx, $2=tag
  local out=""
  out="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "a:$1" \
         -show_entries "stream_tags=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null || true)"
  printf '%s\n' "${out%%$'\n'*}"
}

describe_audio_stream() {
  local i="$1" codec ch layout lang title br kbps
  codec="$(_ap_audio_field "$i" codec_name | tr '[:upper:]' '[:lower:]')"
  ch="$(_ap_audio_field "$i" channels)"; [[ -z "$ch" ]] && ch="?"
  layout="$(_ap_audio_field "$i" channel_layout)"
  lang="$(_ap_audio_tag "$i" language)"; [[ -z "$lang" ]] && lang="$TAG_LANGUAGE_DEFAULT"
  title="$(_ap_audio_tag "$i" title)"
  br="$(_ap_audio_field "$i" bit_rate)"
  if [[ $br =~ ^[0-9]+$ && $br -gt 0 ]]; then kbps="$(( br / 1000 ))kbps"; else kbps=""; fi
  printf "#%s: %s %s%s [%s]%s%s\n" \
    "$i" "${codec:-?}" "${ch}" "${layout:+ ($layout)}" "$lang" "${title:+ — $title}" "${kbps:+, $kbps}"
}

_muxm_codec_rank(){
  local codec; codec="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  local IFS=, pref i=0
  for pref in $AUDIO_CODEC_PREFERENCE; do
    if [[ "$codec" == "$pref" ]]; then echo "$i"; return; fi
    ((i++))
  done
  echo "$i"
}

_muxm_lang_bonus(){
  local lang; lang="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  local IFS=, pref
  for pref in $AUDIO_LANG_PREF; do
    if [[ "$lang" == "$pref" ]]; then echo "$AUDIO_SCORE_LANG_BONUS_ENG"; return; fi
  done
  echo 0
}

score_audio_stream() {
  local i="$1" codec ch lang score=0 rank
  codec="$(_ap_audio_field "$i" codec_name | tr '[:upper:]' '[:lower:]')"
  ch="$(_ap_audio_field "$i" channels)"; [[ -z "$ch" ]] && ch=2
  lang="$(_ap_audio_tag "$i" language | tr '[:upper:]' '[:lower:]')"
  rank="$(_muxm_codec_rank "$codec")"
  (( score += 400 - (rank*80) ))
  (( score += ch * AUDIO_SCORE_CHANNEL_MULTIPLIER ))
  (( ch >= 6 )) && (( score += AUDIO_SCORE_SURROUND_BONUS ))
  (( score += $(_muxm_lang_bonus "$lang") ))
  echo "$score"
}

auto_select_best_audio() {
  local idxs=() i score best_idx=0 best_score=-1
  while IFS= read -r i; do [[ -n "$i" ]] && idxs+=("$i"); done < <(list_audio_indices)
  (( ${#idxs[@]} == 0 )) && { echo 0; return; }
  for i in "${idxs[@]}"; do
    score="$(score_audio_stream "$i")"
    (( score > best_score )) && { best_score="$score"; best_idx="$i"; }
  done
  echo "$best_idx"
}

resolve_audio_track_index() {
  local idxs=() i
  while IFS= read -r i; do [[ -n "$i" ]] && idxs+=("$i"); done < <(list_audio_indices)

  if [[ -n "${AUDIO_TRACK_OVERRIDE:-}" ]]; then
    [[ $AUDIO_TRACK_OVERRIDE =~ ^[0-9]+$ ]] || die 11 "--audio-track must be a non-negative integer"
    printf '%s\n' "${idxs[@]}" | grep -qx "$AUDIO_TRACK_OVERRIDE" || die 11 "Requested --audio-track $AUDIO_TRACK_OVERRIDE not found"
    echo "$AUDIO_TRACK_OVERRIDE"; return
  fi

  (( ${#idxs[@]} > 0 )) && { auto_select_best_audio; return; }
  echo 0
}

# ===== Section 26: Temp paths (used by pipelines) =============================================
V_SRC_DV="$WORKDIR/video_src.hevc"
V_SRC_ES="$WORKDIR/video_src.es"
RPU_P7="$WORKDIR/rpu_p7.bin"
RPU_P81="$WORKDIR/rpu_p81.bin"
V_BASE="$WORKDIR/video_base.hevc"
V_MIXED="$WORKDIR/video_mixed.hevc"

A_PRIMARY=""
AAC_STEREO=""

# ===== Section 27: Video pipeline function (old Sections 27–30) ===============================
# Encapsulates: demux → (optional) DV RPU extract → base x265 encode → DV inject/convert/fallback
run_video_pipeline() {
  # ---- 27A. Demux to raw elementary stream (Annex-B when needed) -----------------------------
  say "→ Preparing raw video elementary stream…"

  demux_to_annexb() {
    # $1=src, $2=out, $3=need_annexb(0|1)
    local src="$1" out="$2" need_annexb="${3:-0}" vcodec fmt bsf
    vcodec="$(_vcodec_name "$src")"
    case "$vcodec" in
      hevc|h265) fmt="hevc"; bsf="hevc_mp4toannexb" ;;
      h264|avc1) fmt="h264"; bsf="h264_mp4toannexb" ;;
      *)
        warn "Unknown/unsupported video codec for raw ES demux ($vcodec); creating placeholder."
        if (( ! DRY_RUN )); then : > "$out"; fi
        return 0
        ;;
    esac

    if (( DRY_RUN )); then
      local _annex_hint=""; [[ "$need_annexb" == "1" || $ANNEXB_FOR_DEMUX -ne 0 ]] && _annex_hint=" (Annex-B)"
      say "DRY-RUN: demux raw $fmt${_annex_hint} → $out"
      return 0
    fi

    if [[ "$need_annexb" == "1" || $ANNEXB_FOR_DEMUX -ne 0 ]]; then
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$src" -map 0:v:0 -c copy -bsf:v "$bsf" -f "$fmt" "$out"
    else
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$src" -map 0:v:0 -c copy                 -f "$fmt" "$out"
    fi
  }

  # Pick DV path when present (fast check; a separate detect ran earlier for user info)
  if (( DISABLE_DV == 0 )) && ffprobe "${FFPROBE_FLAGS[@]}" -show_streams -select_streams v:0 "$SRC_ABS" 2>/dev/null | grep -m1 -qiE 'dolby_vision|dv_profile|dovi|dvhe|dvh1|com\.dolby\.vision'; then
    demux_to_annexb "$SRC_ABS" "$V_SRC_DV" 1
    mark_done "Demux DV Annex-B → $(basename "$V_SRC_DV")"
    IS_DV=1
  else
    demux_to_annexb "$SRC_ABS" "$V_SRC_ES" 1
    mark_done "Demux raw ES → $(basename "$V_SRC_ES")"
    IS_DV=0
  fi

  # ---- 27B. DV RPU extraction (if DV present) ------------------------------------------------
  if (( IS_DV == 1 && DISABLE_DV == 0 )); then
    say "→ Extracting Dolby Vision RPU → $RPU_P7"
    dv_extract_rpu() {
      local in="$1" out="$2"
      if (( DRY_RUN )); then
        say "DRY-RUN: dovi_tool extract-rpu → $out"
        return 0
      fi
      dovi_tool extract-rpu -i "$in" -o "$out"
    }
    if dv_extract_rpu "$V_SRC_DV" "$RPU_P7"; then
      mark_done "Extract DV RPU"
    else
      if (( ALLOW_DV_FALLBACK )); then
        warn "RPU extract failed; proceeding without DV."
        IS_DV=0
      else
        die 20 "DV RPU extract failed. Set ALLOW_DV_FALLBACK=1 or use --no-dv to continue without DV."
      fi
    fi
  fi

  # ---- 27C. Base video encode (x265) ---------------------------------------------------------
  say "→ Encoding base video ($PROFILE_DESC, $TARGET_PIXFMT, preset $PRESET_VALUE, CRF $CRF_VALUE) → $V_BASE"
  if (( DRY_RUN )); then
    say "DRY-RUN: x265 encode (CRF $CRF_VALUE, preset $PRESET_VALUE) → $V_BASE"
  else
    ffargs=( "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:v:0 -c:v libx265 -preset "$PRESET_VALUE" -crf "$CRF_VALUE" -pix_fmt "$TARGET_PIXFMT" )
    [[ -n "$THREADS" ]] && ffargs+=( -threads "$THREADS" )

    if [[ "$PROFILE_DESC" == "HDR10" ]]; then
      ffmpeg "${ffargs[@]}" -x265-params "$X265_PARAMS" \
        -color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc -color_range tv \
        -an "$V_BASE"
    else
      ffmpeg "${ffargs[@]}" -x265-params "$X265_PARAMS" "${COLOR_ARGS[@]}" -an "$V_BASE"
    fi
  fi
  mark_done "Encode base video"

  # ---- 27D. DV inject / P7→P8.1 convert (else copy base) -------------------------------------
  say "→ Finalizing video stream (DV inject if available) → $V_MIXED"

  dv_inject_with_rpu(){
    local base="$1" out="$2" rpu="$3"
    if (( DRY_RUN )); then
      say "DRY-RUN: dovi_tool inject-rpu → $out"
      return 0
    fi
    dovi_tool inject-rpu -i "$base" -r "$rpu" -o "$out"
  }

  dv_convert_p7_to_p81(){
    local in="$1" out="$2"
    if (( DRY_RUN )); then
      say "DRY-RUN: dovi_tool convert-rpu P7→P8.1 → $out"
      return 0
    fi
    if dovi_tool convert-rpu --input-rpu "$in" --profile 8.1 --output-rpu "$out" 2>/dev/null; then
      return 0
    fi
    dovi_tool --convert --input-rpu "$in" --profile 8.1 --output-rpu "$out"
  }

  if (( IS_DV == 1 && DISABLE_DV == 0 )); then
    if dv_inject_with_rpu "$V_BASE" "$V_MIXED" "$RPU_P7"; then
      note "DV injection succeeded with extracted RPU (treated as P8.x)."
      mark_done "DV inject (pass-through)"
    else
      if (( DV_CONVERT_TO_P81_IF_FAIL )); then
        note "Initial DV injection failed — attempting P7→P8.1 conversion."
        if dv_convert_p7_to_p81 "$RPU_P7" "$RPU_P81" && dv_inject_with_rpu "$V_BASE" "$V_MIXED" "$RPU_P81"; then
          note "RPU converted and injection succeeded (Profile 7 → P8.1)."
          mark_done "DV convert+inject"
        else
          if (( ALLOW_DV_FALLBACK )); then
            warn "DV conversion/injection failed; using non-DV base video."
            cp_or_dryrun "$V_BASE" "$V_MIXED"
            IS_DV=0
          else
            die 22 "DV conversion/injection failed. Set ALLOW_DV_FALLBACK=1 or --no-dv to continue without DV."
          fi
        fi
      else
        if (( ALLOW_DV_FALLBACK )); then
          warn "DV injection failed; DV conversion disabled. Using non-DV base video."
          cp_or_dryrun "$V_BASE" "$V_MIXED"
          IS_DV=0
        else
          die 22 "DV injection failed and DV conversion is disabled."
        fi
      fi
    fi
  else
    cp_or_dryrun "$V_BASE" "$V_MIXED"
    mark_done "Use base video (non-DV)"
  fi
}

# ===== Section 28: Audio pipeline function (old Sections 31–33) ===============================
# Encapsulates: presence/index resolve → container decisions → (copy|transcode) + stereo add
run_audio_pipeline() {
  # ---- 28A. Audio presence & index resolve ---------------------------------------------------
  local i
  if _has_stream "$SRC_ABS" audio; then
    HAS_AUDIO=1
  else
    HAS_AUDIO=0
  fi

  if (( HAS_AUDIO )); then
    AIDX="$(resolve_audio_track_index)"
    A_LANG="$(_ap_audio_tag "$AIDX" language)"; [[ -z "$A_LANG" ]] && A_LANG="$TAG_LANGUAGE_DEFAULT"
    note "[Audio Select] Using track #$AIDX: $(describe_audio_stream "$AIDX")"

    say "• Detected audio streams:"
    for i in $(list_audio_indices); do describe_audio_stream "$i" || true; done
  else
    AIDX=0
    A_LANG="$TAG_LANGUAGE_DEFAULT"
    note "No audio tracks detected; continuing with video-only."
  fi

  # ---- 28B. Audio formats & temp names -------------------------------------------------------
  ACODEC="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a:"$AIDX" -show_entries stream=codec_name -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 | tr '[:upper:]' '[:lower:]' || true)"
  ACHANNELS="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a:"$AIDX" -show_entries stream=channels   -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 || true)"
  [[ -z "$ACHANNELS" ]] && ACHANNELS=2

  ADD_STEREO=0
  (( ACHANNELS > 2 )) && ADD_STEREO=1

  A_PRIMARY_FMT=""
  case "$ACODEC" in
    aac)   A_PRIMARY="$WORKDIR/audio_primary.m4a" ;;
    eac3)  A_PRIMARY="$WORKDIR/audio_primary.eac3"; A_PRIMARY_FMT="eac3" ;;
    ac3)   A_PRIMARY="$WORKDIR/audio_primary.ac3";  A_PRIMARY_FMT="ac3"  ;;
    *)     A_PRIMARY="$WORKDIR/audio_primary.m4a" ;;  # default container for AAC
  esac
  AAC_STEREO="$WORKDIR/stereo.m4a"

  # ---- 28C. Audio preparation (primary + optional stereo) -----------------------------------
  start_aac_stereo_job() {
    if (( DRY_RUN )); then
      say "DRY-RUN: would encode AAC stereo → $AAC_STEREO"
      return 0
    fi
    if [[ -n "$THREADS" ]]; then
      ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
    else
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
    fi
  }

  prepare_primary_audio_copy_or_transcode() {
    if (( DRY_RUN )); then
      say "DRY-RUN: would prepare primary audio ($ACODEC, ${ACHANNELS}ch) → $A_PRIMARY"
      return 0
    fi

    # Copy when Direct Play-friendly (AAC/EC-3/AC-3); otherwise transcode.
    if [[ "$ACODEC" == "aac" || "$ACODEC" == "eac3" || "$ACODEC" == "ac3" ]]; then
      if [[ "$ACODEC" == "aac" ]]; then
        ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy -movflags +faststart -f mp4 "$A_PRIMARY"
      else
        ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy ${A_PRIMARY_FMT:+-f "$A_PRIMARY_FMT"} "$A_PRIMARY"
      fi
      note "Direct Play audio codec detected ($ACODEC). Copying without conversion."
      return 0
    fi

    if (( ACHANNELS <= 2 )); then
      if [[ -n "$THREADS" ]]; then
        ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
          -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY"
      else
        ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
          -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY"
      fi
      note "Unsupported stereo codec ($ACODEC). Transcoding to AAC $STEREO_BITRATE."
    else
      local channels_to_keep="$ACHANNELS"
      (( channels_to_keep > MAX_AUDIO_CHANNELS )) && channels_to_keep="$MAX_AUDIO_CHANNELS"
      A_PRIMARY="$WORKDIR/audio_primary.eac3"; A_PRIMARY_FMT="eac3"
      local _eac3_br; if (( channels_to_keep >= 7 )); then _eac3_br="$EAC3_BITRATE_7_1"; else _eac3_br="$EAC3_BITRATE_5_1"; fi
      if [[ -n "$THREADS" ]]; then
        ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
          -c:a eac3 -b:a "$_eac3_br" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY"
      else
        ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
          -c:a eac3 -b:a "$_eac3_br" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY"
      fi
      note "Unsupported multichannel codec ($ACODEC). Transcoding to E-AC-3 $_eac3_br."
    fi
  }

  if (( HAS_AUDIO )); then
    if (( PARALLEL_AUDIO )); then
      say "→ Preparing primary audio (parallel) → $A_PRIMARY"
      ( prepare_primary_audio_copy_or_transcode ) & PID_PRIMARY=$!
      if (( ADD_STEREO )) && (( ADD_STEREO_IF_MULTICH )); then
        say "→ Creating AAC stereo fallback (parallel) → $AAC_STEREO"
        ( start_aac_stereo_job ) & PID_STEREO=$!
      fi
      PRIMARY_STATUS=0; STEREO_STATUS=0
      [[ -n "${PID_PRIMARY:-}" ]] && { if ! wait "$PID_PRIMARY"; then PRIMARY_STATUS=$?; kill_if_running "$PID_STEREO"; fi; }
      [[ -n "${PID_STEREO:-}"  ]] && { if ! wait "$PID_STEREO";  then STEREO_STATUS=$?;  kill_if_running "$PID_PRIMARY"; fi; }
      (( PRIMARY_STATUS != 0 )) && die 30 "Primary audio job failed (exit $PRIMARY_STATUS)."
      (( ADD_STEREO == 1 && ADD_STEREO_IF_MULTICH == 1 && STEREO_STATUS != 0 )) && die 31 "Stereo fallback job failed (exit $STEREO_STATUS)."

      mark_done "Primary audio prepared (parallel)"
      (( ADD_STEREO && ADD_STEREO_IF_MULTICH )) && mark_done "Create AAC stereo (parallel)"
    else
      say "→ Preparing primary audio → $A_PRIMARY"
      prepare_primary_audio_copy_or_transcode
      mark_done "Primary audio prepared"

      if (( ADD_STEREO )) && (( ADD_STEREO_IF_MULTICH )); then
        say "→ Creating AAC stereo fallback → $AAC_STEREO"
        start_aac_stereo_job
        mark_done "Create AAC stereo"
      else
        note "Primary audio is stereo (or fallback disabled); no extra stereo needed."
      fi
    fi
  else
    note "No audio tracks detected; proceeding without audio."
  fi
}

# ===== Section 29: Subtitle helpers (safe under -e) ===========================================
# All helpers here avoid aborting the script under set -e. Any predicate test that returns 1 is
# guarded so it is not treated as a failure.

# Count positional subtitle streams
_sub_count() {
  local n
  n="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams s \
        -show_entries stream=index -of csv=p=0 "$SRC_ABS" 2>/dev/null | wc -l | tr -d '[:space:]')"
  [[ -n "$n" ]] || n=0
  echo "$n"
}

# List 0..N-1 subtitle indices
list_sub_indices(){
  local n i
  n="$(_sub_count)"
  for (( i=0; i<n; i++ )); do echo "$i"; done
}

# Safe field/tag getters
_sp_sub_field() { # $1=idx, $2=field (codec_name, etc.)
  ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "s:$1" \
    -show_entries "stream=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 || true
}
_sp_sub_tag() {   # $1=idx, $2=tag (language,title)
  ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "s:$1" \
    -show_entries "stream_tags=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 || true
}
_sp_sub_dispo_forced(){ # 1 if forced disposition present
  ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "s:$1" -show_entries stream_disposition=forced \
    -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 | awk '{print ($1+0)}' || echo 0
}

# Normalize language (fallback to TAG_LANGUAGE_DEFAULT if empty)
_sp_sub_lang(){ # $1=idx
  local lang; lang="$(_sp_sub_tag "$1" language | tr '[:upper:]' '[:lower:]')"
  [[ -z "$lang" ]] && lang="$TAG_LANGUAGE_DEFAULT"
  echo "$lang"
}

_is_forced_title(){
  local t; t="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  [[ "$t" =~ forced|signs|foreign ]] && return 0 || return 1
}
_is_sdh_title(){
  local t; t="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  [[ "$t" =~ (^|[^a-z])(sdh|hi)([^a-z]|$)|hearing|impaired|cc|caption ]] && return 0 || return 1
}

describe_sub_stream(){
  local i="$1" codec lang title forced flags=""
  codec="$(_sp_sub_field "$i" codec_name | tr '[:upper:]' '[:lower:]')"
  lang="$(_sp_sub_lang "$i")"
  title="$(_sp_sub_tag "$i" title)"
  forced="$(_sp_sub_dispo_forced "$i")"
  (( forced )) && flags=" (forced)"
  if _is_sdh_title "$title"; then
    [[ -n "$flags" ]] && flags="$flags, "
    flags="${flags}SDH"
  fi
  printf "#%s: %s [%s]%s%s\n" "$i" "${codec:-?}" "$lang" "${title:+ — $title}" "$flags"
}

# Convert/copy a subtitle stream to SRT in WORKDIR. Always non-fatal.
_prepare_sub_to_srt(){ # $1=idx -> echoes path on success, empty otherwise
  local idx="$1" codec srt sup
  codec="$(_sp_sub_field "$idx" codec_name | tr '[:upper:]' '[:lower:]')"
  srt="$WORKDIR/sub.${idx}.srt"

  if (( DRY_RUN )); then
    # Create a tiny valid SRT *in-memory path only if you want later checks to see it.*
    # We will actually create the file to make -s checks pass during dry-run planning.
    printf "1\n00:00:00,000 --> 00:00:00,500\n(dry-run)\n" >"$srt" 2>/dev/null || true
    echo "$srt"; return 0
  fi

  case "$codec" in
    subrip|srt)
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:s:"$idx" -c copy "$srt" && { echo "$srt"; return 0; } ;;
    ass|ssa|webvtt|vtt)
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:s:"$idx" "$srt" && { echo "$srt"; return 0; } ;;
    hdmv_pgs_subtitle|pgs)
      # Convert PGS (.sup) → VobSub (.idx/.sub) via ffmpeg, then OCR to .srt with sub2srt.
      if (( SUB_ENABLE_OCR )); then
        sup="$WORKDIR/sub.${idx}.sup"
        vob_base="$WORKDIR/sub.${idx}.vob"   # will produce sub.${idx}.vob.idx and .sub
        # 1) Extract the PGS bitmaps to a .sup file
        if (( DRY_RUN )); then
          say "DRY-RUN: extract PGS #$idx → $sup"
        else
          ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:s:"$idx" -c:s copy "$sup" || { echo ""; return 0; }
        fi
        # 2) Convert .sup → .idx/.sub using ffmpeg's vobsub muxer (codec dvdsub)
        if (( DRY_RUN )); then
          say "DRY-RUN: ffmpeg PGS→VobSub ($sup → ${vob_base}.idx/.sub)"
        else
          # -f vobsub chooses the idx/sub muxer; -c:s dvdsub creates VobSub bitmaps
          if ! ffmpeg "${FFMPEG_FLAGS[@]}" -i "$sup" -map 0:s:0 -c:s dvdsub -f vobsub "$vob_base"; then
            warn "PGS→VobSub conversion failed for #$idx — skipping OCR."
            echo ""; return 0
          fi
        fi
        # 3) OCR the VobSub pair → .srt via sub2srt
        if (( DRY_RUN )); then
          say "DRY-RUN: ${SUB_OCR_TOOL} ${vob_base}.idx (→ ${vob_base}.srt)"
          # create a tiny placeholder so later -s checks pass
          printf "1\n00:00:00,000 --> 00:00:00,500\n(dry-run)\n" >"$srt" 2>/dev/null || true
          echo "$srt"; return 0
        else
          # sub2srt usually writes <basename>.srt in place; some builds accept -l.
          if "$SUB_OCR_TOOL" "${vob_base}.idx" >/dev/null 2>&1; then
            :
          elif "$SUB_OCR_TOOL" -l "$SUB_OCR_LANG" "${vob_base}.idx" >/dev/null 2>&1; then
            :
          else
            warn "sub2srt OCR failed for #$idx — skipping."
            echo ""; return 0
          fi
          # Move/rename produced SRT to the expected path if needed
          if [[ -s "${vob_base}.srt" ]]; then
            mv -f "${vob_base}.srt" "$srt" || true
          fi
          if [[ -s "$srt" ]]; then
            echo "$srt"; return 0
          else
            warn "OCR produced no SRT for #$idx — skipping."
          fi
        fi
      else
        warn "PGS #$idx requires OCR but OCR is disabled — skipping."
      fi
      ;;
    *)
      warn "Unsupported subtitle codec '$codec' for #$idx — skipping."
      ;;
  esac
  echo ""; return 0
}

# ===== Section 30: Subtitle selection planner (safe & with fallback) ==========================
# Populates SRT_FORCED / SRT_FULL / SRT_SDH (paths) and SRT_DIRECT_MAP=1 if nothing prepared.
SRT_FORCED=""; SRT_FULL=""; SRT_SDH=""; SRT_DIRECT_MAP=0

build_subtitle_plan(){
  local have_subs=0 i
  _has_stream "$SRC_ABS" subtitle && have_subs=1
  (( have_subs )) || { note "[Subs] No subtitle streams detected."; SRT_DIRECT_MAP=0; return 0; }

  say "→ Scanning subtitle streams:"
  for i in $(list_sub_indices); do describe_sub_stream "$i" || true; done

  local lang title forced is_sdh pref=",$SUB_LANG_PREF,"
  local forced_idx="" full_idx="" sdh_idx=""

  for i in $(list_sub_indices); do
    lang="$(_sp_sub_lang "$i")"
    [[ ",$SUB_LANG_PREF," == *",$lang,"* ]] || continue

  title="$(_sp_sub_tag "$i" title)"
  forced="$(_sp_sub_dispo_forced "$i")"
  if _is_sdh_title "$title"; then
    is_sdh=0
  else
    is_sdh=1
  fi

    if (( SUB_INCLUDE_FORCED )) && { (( forced )) || _is_forced_title "$title"; }; then
      [[ -z "$forced_idx" ]] && forced_idx="$i"
      continue
    fi
    if (( SUB_INCLUDE_SDH )) && [[ $is_sdh -eq 0 ]]; then
      [[ -z "$sdh_idx" ]] && sdh_idx="$i"
      continue
    fi
    if (( SUB_INCLUDE_FULL )) && [[ $is_sdh -ne 0 ]]; then
      [[ -z "$full_idx" ]] && full_idx="$i"
      continue
    fi
  done

  # Materialize top picks to SRT (respect SUB_MAX_TRACKS implicitly: up to 3)
  local p pick_count=0
  if [[ -n "$forced_idx" ]]; then
    p="$(_prepare_sub_to_srt "$forced_idx")"; [[ -n "$p" ]] && SRT_FORCED="$p" && ((pick_count++)) && note "[Subs] Prepared Forced → $SRT_FORCED"
  fi
  if [[ -n "$full_idx" && $pick_count -lt $SUB_MAX_TRACKS ]]; then
    p="$(_prepare_sub_to_srt "$full_idx")"; [[ -n "$p" ]] && SRT_FULL="$p" && ((pick_count++)) && note "[Subs] Prepared Full → $SRT_FULL"
  fi
  if [[ -n "$sdh_idx" && $pick_count -lt $SUB_MAX_TRACKS ]]; then
    p="$(_prepare_sub_to_srt "$sdh_idx")"; [[ -n "$p" ]] && SRT_SDH="$p" && ((pick_count++)) && note "[Subs] Prepared SDH → $SRT_SDH"
  fi

  # Fallback: if none prepared, enable direct-map of embedded ENG (or first matching) subs later.
  if [[ -z "$SRT_FORCED" && -z "$SRT_FULL" && -z "$SRT_SDH" ]]; then
    SRT_DIRECT_MAP=1
    note "[Subs] No external SRTs prepared — enabling direct-map fallback."
  fi
}

# ===== Section 31: Orchestration (banner, pipelines, final mux, verify, size) =================
main() {
  # ---- 31A. Human-readable banner (moved here from old Section 20) ---------------------------
  say "=== ${APP_NAME} v${VERSION} — CLI: ${CLI_NAME}"
  say "=== Input      : $SRC_ABS"
  say "=== Output     : $OUT"
  say "=== Workdir    : $WORKDIR"
  say "=== Defaults   : CRF=$CRF_VALUE  StereoBitrate=$STEREO_BITRATE  Preset=$PRESET_VALUE"
  (( DRY_RUN )) && note "DRY-RUN is ON"
  [[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]] && note "Config layers: ${MUXM_CONFIG_LOADED[*]}"
  (( SKIP_VIDEO )) && note "[Quick Test] Video processing disabled (--skip-video)"
  (( SKIP_AUDIO )) && note "[Quick Test] Audio processing disabled (--skip-audio)"
  (( SKIP_SUBS  )) && note "[Quick Test] Subtitle processing disabled (--skip-subs)"

  # ---- 31B. Video pipeline -------------------------------------------------------------------
  if (( SKIP_VIDEO )); then
    note "[Quick Test] --skip-video: skipping video demux/encode/DV"
    IS_DV=0
    V_SRC_DV=""; V_SRC_ES=""; RPU_P7=""; RPU_P81=""
    V_BASE=""; V_MIXED=""
  else
    run_video_pipeline
  fi

  # ---- 31C. Audio pipeline -------------------------------------------------------------------
  if (( SKIP_AUDIO )); then
    note "[Quick Test] --skip-audio: skipping audio selection/transcode"
    HAS_AUDIO=0
    A_PRIMARY=""; AAC_STEREO=""
  else
    run_audio_pipeline
  fi

  # ---- 31D. Subtitle planning (optional) -----------------------------------------------------
  if (( SKIP_SUBS )); then
    note "[Quick Test] --skip-subs: skipping subtitle planning/mapping"
    SRT_FORCED=""; SRT_FULL=""; SRT_SDH=""; SRT_DIRECT_MAP=0
  else
    build_subtitle_plan
  fi

  # ---- 31E. Final MP4 assembly ---------------------------------------------------------------
  say "→ Muxing final MP4 with ffmpeg → $TMP_OUT"

  # Dry-run: do not invoke ffmpeg; create an empty placeholder and record the step.
  if (( DRY_RUN )); then
    say "DRY-RUN: final ffmpeg mux → $TMP_OUT"
    : > "$TMP_OUT" 2>/dev/null || true
    mark_done "Mux final MP4 (dry-run)"
  else
    # Build input list (ordered). We build indices explicitly to keep -map stable.
    ff_in=( -hide_banner -loglevel "$FFMPEG_LOGLEVEL" -y )
    local next_idx=0

    # Video input (if produced)
    local vid_idx=""
    if [[ -n "${V_MIXED:-}" && -s "$V_MIXED" ]]; then
      ff_in+=( -i "$V_MIXED" ); vid_idx=$next_idx; ((next_idx++))
    fi

    # Audio inputs (if produced)
    local a_primary_idx="" a_stereo_idx=""
    if (( HAS_AUDIO )) && [[ -n "${A_PRIMARY:-}" && -s "$A_PRIMARY" ]]; then
      ff_in+=( -i "$A_PRIMARY" ); a_primary_idx=$next_idx; ((next_idx++))
    fi
  if [[ -n "${AAC_STEREO:-}" && -s "$AAC_STEREO" ]]; then
    ff_in+=( -i "$AAC_STEREO" ); a_stereo_idx=$next_idx; ((next_idx++))
  fi

    # External SRTs (if any and not skipped)
    local forced_present=0 full_present=0 sdh_present=0
    local s_forced_idx="" s_full_idx="" s_sdh_idx=""
    if (( ! SKIP_SUBS )); then
      if [[ -n "${SRT_FORCED:-}" && -s "$SRT_FORCED" ]]; then
        ff_in+=( -i "$SRT_FORCED" ); s_forced_idx=$next_idx; ((next_idx++)); forced_present=1
      fi
      if [[ -n "${SRT_FULL:-}"   && -s "$SRT_FULL"   ]]; then
        ff_in+=( -i "$SRT_FULL"   ); s_full_idx=$next_idx;   ((next_idx++)); full_present=1
      fi
      if [[ -n "${SRT_SDH:-}"    && -s "$SRT_SDH"    ]]; then
        ff_in+=( -i "$SRT_SDH"    ); s_sdh_idx=$next_idx;    ((next_idx++)); sdh_present=1
      fi
    fi

    # Direct-map fallback: only if not skipping subs and no external SRTs prepared.
    local src_sub_idx=""
    if (( ! SKIP_SUBS )) && (( SRT_DIRECT_MAP )) && (( !forced_present && !full_present && !sdh_present )); then
      ff_in+=( -i "$SRC_ABS" ); src_sub_idx=$next_idx; ((next_idx++))
    fi

    # Construct maps in the same order we added inputs.
    ff_map=()
    if [[ -n "$vid_idx" ]]; then
      ff_map+=( -map "$vid_idx":v:0 )
    fi
    if [[ -n "$a_primary_idx" ]]; then
      ff_map+=( -map "$a_primary_idx":a:0 )
    fi
    if [[ -n "$a_stereo_idx" ]]; then
      ff_map+=( -map "$a_stereo_idx":a:0 )
    fi

    # Subtitles: map external SRTs in a stable order; then optional direct-map.
    sub_order=()
    if (( forced_present )); then ff_map+=( -map "$s_forced_idx":s:0 ); sub_order+=("forced"); fi
    if (( full_present   )); then ff_map+=( -map "$s_full_idx":s:0   ); sub_order+=("full");   fi
    if (( sdh_present    )); then ff_map+=( -map "$s_sdh_idx":s:0    ); sub_order+=("sdh");    fi

    if [[ -n "$src_sub_idx" ]]; then
      # Map the first English-flagged subtitle from the source, if present.
      ff_map+=( -map "$src_sub_idx":s:m:language:eng? )
    fi

    # If literally nothing was mapped (e.g., all --skip-*), fail fast with guidance.
    if (( ${#ff_map[@]} == 0 )); then
      die 42 "No streams selected for output (video/audio/subs all skipped or unavailable). Remove a --skip-* flag."
    fi

    # Codecs: copy v/a; transcode subs to mov_text if we added any subtitle inputs.
    ff_codec=( -c copy )
    if (( forced_present || full_present || sdh_present )) || [[ -n "$src_sub_idx" ]]; then
      ff_codec+=( -c:s mov_text )
    fi
    ff_codec+=( -movflags +faststart )

    # Metadata: annotate audio language/title; label external SRTs.
    ff_meta=()
    local aout=0
    local _alang="${A_LANG:-$TAG_LANGUAGE_DEFAULT}"
    if [[ -n "$a_primary_idx" ]]; then
      ff_meta+=( -metadata:s:a:"$aout" language="$_alang" ); ((aout++))
    fi
    if [[ -n "$a_stereo_idx" ]]; then
      ff_meta+=( -metadata:s:a:"$aout" language="$_alang" -metadata:s:a:"$aout" title="Stereo" ); ((aout++))
    fi

    local sn=0
    for kind in "${sub_order[@]}"; do
      case "$kind" in
        forced)
          ff_meta+=(
            -metadata:s:s:"$sn" language=eng
            -metadata:s:s:"$sn" title="English (Forced)"
            -metadata:s:s:"$sn" handler_name="English (Forced)"
            -disposition:s:"$sn" forced+default
          )
          ;;
        full)
          ff_meta+=(
            -metadata:s:s:"$sn" language=eng
            -metadata:s:s:"$sn" title="English"
            -metadata:s:s:"$sn" handler_name="English"
            -disposition:s:"$sn" 0
          )
          ;;
        sdh)
          ff_meta+=(
            -metadata:s:s:"$sn" language=eng
            -metadata:s:s:"$sn" title="English (SDH)"
            -metadata:s:s:"$sn" handler_name="English (SDH)"
            -disposition:s:"$sn" 0
          )
          ;;
      esac
      ((sn++))
    done

    if [[ -n "$src_sub_idx" ]]; then
      ff_meta+=(
        -metadata:s:s:"$sn" language=eng
        -metadata:s:s:"$sn" title="English"
        -metadata:s:s:"$sn" handler_name="English"
        -disposition:s:"$sn" 0
      )
      ((sn++))
    fi

    # Execute final mux
    if ! ffmpeg "${ff_in[@]}" "${ff_map[@]}" "${ff_codec[@]}" "${ff_meta[@]}" \
      -f "$MUX_FORMAT" "$TMP_OUT"; then
      die 41 "ffmpeg final mux failed"
    fi
    mark_done "Mux final MP4"
  fi

  # ---- 31F. DV presence note -----------------------------------------------------------------
  if (( IS_DV == 1 && DISABLE_DV == 0 )); then
    note "Dolby Vision present in output (P8.1 injected or pass-through)."
  else
    note "Output is non-DV (HDR10/HLG/SDR as applicable)."
  fi

  # ---- 31G. Verification ---------------------------------------------------------------------
  say "→ Verifying output streams…"
  if (( DRY_RUN )); then
    say "DRY-RUN: ffprobe verify $TMP_OUT"
  else
    ffprobe -hide_banner -show_streams "$TMP_OUT" | sed -n '1,160p' || true
  fi
  mark_done "Verify output"

  # ---- 31H. Output size ----------------------------------------------------------------------
  say "→ Output (temp) size:"
  if (( DRY_RUN )); then
    say "DRY-RUN: size of $TMP_OUT"
  else
    filesize_pretty "$TMP_OUT"
  fi

  note "✅ Staging complete — will atomically move to: $OUT"
}

# ===== Section 32: Program entry point ========================================================
# All helpers and pipelines are defined above; traps will manage finalization.
main "$@"