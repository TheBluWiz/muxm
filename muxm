#!/usr/bin/env bash
# =============================================================================
#  MuxMaster™ Freeware License v1.0
#  Copyright © 2025 Jamey Wicklund (theBluWiz)
# =============================================================================
# Universal DV/HLG/HDR10/SDR → MP4 (Apple TV Direct Play) Encoder
# Requires: ffmpeg, ffprobe, MP4Box, dovi_tool >= 2.0
# =============================================================================

set -eEuo pipefail  # -E ensures ERR trap is inherited in functions/subshells
if shopt -q inherit_errexit 2>/dev/null; then shopt -s inherit_errexit; fi
[[ "${DEBUG:-0}" == "1" ]] && set -x

# ---------- Globals ----------
declare -a COMPLETED_STEPS=()
WORKDIR=""
LOGFILE=""

readonly APP_NAME="MuxMaster"
readonly CLI_NAME="muxm"
readonly VERSION="1.1"

# Integer flags (standardized numeric checks)
ALLOW_DV_FALLBACK="${ALLOW_DV_FALLBACK:-1}"  # env-overridable default
PARALLEL_AUDIO=0
CHECKSUM=0
DRY_RUN=0
KEEP_TEMP=0            # keep working files on FAILURE
KEEP_TEMP_ALWAYS=0     # keep on SUCCESS and FAILURE
DISABLE_DV=0           # force-disable DV handling even if present

# Tunables
LEVEL_VALUE=""         # x265 level-idc via --level/-l
PRESET_VALUE="slower"  # default preset unless -p/--preset overrides
CRF_VALUE=18
STEREO_BITRATE=192k
THREADS=""             # if set, pass -threads N to ffmpeg encodes

readonly FFMPEG_FLAGS="-hide_banner -loglevel error -y"
readonly FFPROBE_FLAGS="-v error"

X265_PARAMS_BASE='profile=main10:repeat-headers=1:hdr-opt=1:aq-mode=3:aq-strength=1.3:psy-rd=2.0:psy-rdoq=1.0:rc-lookahead=60'
X265_PARAMS="$X265_PARAMS_BASE"

say()  { printf "%s\n" "$*" >&2; }
note() { printf "ℹ️  %s\n" "$*" >&2; }
warn() { printf "⚠️  %s\n" "$*" >&2; }

FAILED=0
FAIL_MSG=""
EXIT_CODE=1

die()  { local code=1; if [[ $# -gt 1 && "$1" =~ ^[0-9]+$ ]]; then code="$1"; shift; fi; FAILED=1; EXIT_CODE="$code"; FAIL_MSG="Fatal: $*"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; exit "$code"; }
on_error(){ local lineno="$1" cmd="$2" status="$3"; FAILED=1; EXIT_CODE="${EXIT_CODE:-$status}"; FAIL_MSG="Command failed at line $lineno: $cmd (exit $status)"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; }
mark_done(){ COMPLETED_STEPS+=("$1"); }

need(){ command -v "$1" >/dev/null 2>&1 || die 10 "Missing required tool: $1"; }
timestamp(){ date +"%Y-%m-%d %H:%M:%S"; }
realpath_fallback(){ if command -v realpath >/dev/null 2>&1; then realpath "$1"; else echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"; fi; }
filesize_pretty(){ if command -v gstat >/dev/null 2>&1; then gstat -c "%n %s bytes" "$1"; else ls -lh "$1"; fi; }
kill_if_running(){ local pid="${1:-}"; [[ -n "$pid" ]] || return 0; if kill -0 "$pid" 2>/dev/null; then kill "$pid" 2>/dev/null || true; fi; }
checksum_cmd(){ command -v sha256sum >/dev/null 2>&1 && { echo "sha256sum"; return; }; command -v shasum >/dev/null 2>&1 && { echo "shasum -a 256"; return; }; echo ""; }
write_checksum(){ local p="$1" c; c="$(checksum_cmd)"; [[ -z "$c" ]] && { warn "Checksum tool not found"; return 0; }; note "Writing checksum → ${p}.sha256"; $c "$p" > "${p}.sha256"; }

# ---------- ffprobe helpers ----------
_probe_field(){ ffprobe $FFPROBE_FLAGS -show_entries "stream=$1" -of default=nk=1:nw=1 "$2" 2>/dev/null | head -n1 || true; }
_has_stream(){ ffprobe $FFPROBE_FLAGS -show_entries stream=codec_type -of default=nk=1:nw=1 "$1" 2>/dev/null | grep -q "$2"; }
_vcodec_name(){ ffprobe $FFPROBE_FLAGS -select_streams v:0 -show_entries stream=codec_name -of default=nk=1:nw=1 "$1" 2>/dev/null | head -n1 || true; }

# ---------- Requirements ----------
need ffmpeg
need ffprobe
need MP4Box
need dovi_tool

# ---------- Usage / CLI ----------
print_usage(){ cat <<EOF
Usage: ${CLI_NAME} [options] <source.mkv|mp4|m4v|mov> [target.mp4]

Options:
  -j, --parallelize                Encode audio tasks in parallel
      --checksum                   Write a SHA-256 checksum file next to output
      --no-checksum                Do not write checksum (overrides env)
      --dry-run                    Plan and print steps without writing output
  -k, --keep-temp                  Keep working files on FAILURE
  -K, --keep-temp-always           Keep working files on SUCCESS and FAILURE
  -l, --level <N>                  Set x265 level-idc (e.g. 5.1)
  -p, --preset <name>              x265 preset: ultrafast..placebo (default: slower)
      --crf <N>                    x265 CRF (default: 18)
      --stereo-bitrate <RATE>      AAC stereo bitrate, e.g. 160k/192k (default: 192k)
      --threads <N>                ffmpeg -threads N for encodes (global default)
      --no-dv                      Disable Dolby Vision handling even if present
  -h, --help                       Show this help
  -V, --version                    Show version
      --install                    Symlink ${CLI_NAME} to /usr/local/bin (may require sudo)
EOF
}

print_version(){ echo "${APP_NAME} v${VERSION} (${CLI_NAME})"; }
do_install(){ local target="/usr/local/bin/${CLI_NAME}" self; self="$(realpath_fallback "$0")"; [[ -w "$(dirname "$target")" ]] || warn "You may need sudo to install to ${target}"; ln -sf "$self" "$target" || die 11 "Failed to create symlink: $target"; note "Installed symlink: $target → $self"; exit 0; }

is_valid_preset(){ case "$1" in ultrafast|superfast|veryfast|faster|fast|medium|slow|slower|veryslow|placebo) return 0;; *) return 1;; esac; }

USAGE_SHORT="Usage: ${CLI_NAME} [options] <source> [target.mp4]"
POSITIONALS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -j|--parallelize) PARALLEL_AUDIO=1; shift ;;
    --checksum) CHECKSUM=1; shift ;;
    --no-checksum) CHECKSUM=0; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    -k|--keep-temp) KEEP_TEMP=1; shift ;;
    -K|--keep-temp-always) KEEP_TEMP_ALWAYS=1; shift ;;
    -l|--level) LEVEL_VALUE="${2:-}"; [[ -z "${LEVEL_VALUE}" ]] && die 11 "Missing value for --level"; shift 2 ;;
    -p|--preset)
      PRESET_VALUE="${2:-}"; [[ -z "${PRESET_VALUE}" ]] && die 11 "Missing value for --preset"
      if ! is_valid_preset "$PRESET_VALUE"; then
        die 11 "Invalid preset: '${PRESET_VALUE}'. Accepted: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo."
      fi
      shift 2 ;;
    --crf) CRF_VALUE="${2:-}"; [[ -z "$CRF_VALUE" ]] && die 11 "Missing value for --crf"; shift 2 ;;
    --stereo-bitrate) STEREO_BITRATE="${2:-}"; [[ -z "$STEREO_BITRATE" ]] && die 11 "Missing value for --stereo-bitrate"; shift 2 ;;
    --threads) THREADS="${2:-}"; [[ -z "$THREADS" ]] && die 11 "Missing value for --threads"; shift 2 ;;
    --no-dv) DISABLE_DV=1; shift ;;
    -h|--help) print_usage; exit 0 ;;
    -V|--version) print_version; exit 0 ;;
    --install) do_install ;;
    --) shift; break ;;
    -*) die 11 "Unknown option: $1. $USAGE_SHORT" ;;
    *) POSITIONALS+=("$1"); shift ;;
  esac
done

SRC="${POSITIONALS[0]:-}"
OUT="${POSITIONALS[1]:-}"

(( ${#POSITIONALS[@]} > 2 )) && die 11 "Too many arguments. $USAGE_SHORT"
[[ -z "$SRC" ]] && { print_usage; exit 0; }

SRC_ABS="$(realpath_fallback "$SRC")"; [[ -f "$SRC_ABS" ]] || die 11 "Source not found: $SRC_ABS"

if [[ -z "${OUT:-}" ]]; then base="${SRC_ABS%.*}"; OUT="${base}.mp4"; fi
OUT_DIR="$(cd "$(dirname "$OUT")" && pwd)"
OUT_BASENAME="$(basename "$OUT")"
OUT_ABS="${OUT_DIR}/${OUT_BASENAME}"
OUT="$OUT_ABS"
TMP_OUT="${OUT}.tmp"

# ---------- Workdir on output volume (mktemp for safety) ----------
WORKDIR="$(mktemp -d "${OUT_DIR}/.muxm.tmp.XXXXXXXX")" || die 11 "Cannot create working directory on output volume under: $OUT_DIR"
LOGFILE="$WORKDIR/muxm.$(date +%Y%m%d-%H%M%S).log"

# ---------- Begin logging to file (tee) ----------
# Write both stdout/stderr to $LOGFILE while still echoing to terminal
if [[ "${DEBUG:-0}" != "1" ]]; then
  # shellcheck disable=SC2069
  exec > >(tee -a "$LOGFILE") 2>&1
  note "Logging to $LOGFILE"
fi

# ---------- Traps ----------
on_exit() {
  # Only consider success if we actually produced a non-empty output file
  local have_result=0
  if [[ -n "${TMP_OUT:-}" && -s "$TMP_OUT" ]]; then
    have_result=1
  elif [[ -n "${OUT:-}" && -s "$OUT" ]]; then
    have_result=1
  fi

  if (( FAILED == 0 && have_result == 1 )); then
    if (( DRY_RUN )); then
      note "DRY-RUN complete — no files were created."
    else
      [[ -f "$TMP_OUT" ]] && mv -f "$TMP_OUT" "$OUT"
      (( CHECKSUM )) && write_checksum "$OUT"
      note "Build SUCCEEDED."
    fi

    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi

    # only add .dryrun when DRY_RUN == 1
    local _suffix=""
    (( DRY_RUN )) && _suffix=".dryrun"
    { echo "Completed: $(timestamp)"; printf "%s\n" "${COMPLETED_STEPS[@]:-}"; } \
      > "${OUT_DIR}/$(basename "${OUT}")${_suffix}.log" 2>/dev/null || true

    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping workdir: $WORKDIR"
    fi
    exit 0
  else
    [[ -z "$FAIL_MSG" ]] && FAIL_MSG="No output produced (likely earlier parse/runtime error)."
    printf "❌ Build FAILED. %s\n" "$FAIL_MSG"

    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi
    echo "See log: $LOGFILE"

    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP -eq 0 && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping failure artifacts at: $WORKDIR"
    fi
    exit "${EXIT_CODE:-1}"
  fi
}
trap 'on_error $LINENO "$BASH_COMMAND" "$?"' ERR
trap 'FAILED=1; EXIT_CODE=130; FAIL_MSG="Interrupted by user (SIGINT)"; exit 130' INT
trap 'FAILED=1; EXIT_CODE=143; FAIL_MSG="Terminated (SIGTERM)"; exit 143' TERM
trap 'on_exit' EXIT

# ---------- Temp paths ----------
V_SRC_DV="$WORKDIR/video_src.hevc"
V_SRC_ES="$WORKDIR/video_src.es"
RPU_P7="$WORKDIR/rpu_p7.bin"
RPU_P81="$WORKDIR/rpu_p81.bin"
V_BASE="$WORKDIR/video_base.hevc"
V_MIXED="$WORKDIR/video_mixed.hevc"
A_PRIMARY=""
AAC_STEREO=""
MP4_BASE="$WORKDIR/primary_base.mp4"

# ---------- Banner ----------
say "=== ${APP_NAME} v${VERSION} — CLI: ${CLI_NAME}"
say "=== Input      : $SRC_ABS"
say "=== Output     : $OUT"
say "=== Workdir    : $WORKDIR"
say "=== Defaults   : CRF=$CRF_VALUE  StereoBitrate=$STEREO_BITRATE  Preset=$PRESET_VALUE"
(( DRY_RUN )) && note "DRY-RUN is ON"

# ---------- Color/DV analysis ----------
IS_DV=0
PROFILE_DESC="SDR"
TARGET_PIXFMT="yuv420p"
COLOR_ARGS=()

decide_color_and_pixfmt() {
  local src="$1" pix prim trc cspace
  pix="$(_probe_field pix_fmt "$src")"; prim="$(_probe_field color_primaries "$src")"
  trc="$(_probe_field color_transfer "$src")"; cspace="$(_probe_field color_space "$src")"
  prim="$(printf %s "$prim"   | tr '[:upper:]' '[:lower:]')"
  trc="$(printf %s "$trc"     | tr '[:upper:]' '[:lower:]')"
  cspace="$(printf %s "$cspace"| tr '[:upper:]' '[:lower:]')"
  pix="$(printf %s "$pix"     | tr '[:upper:]' '[:lower:]')"

  local is_10bit=0 chroma="420"
  [[ "$pix" =~ p10 ]] && is_10bit=1
  [[ "$pix" =~ 422 ]] && chroma="422"; [[ "$pix" =~ 444 ]] && chroma="444"
  [[ "$chroma" != "420" ]] && { warn "Source chroma is 4:${chroma}; downsampling to 4:2:0 for Apple TV Direct Play."; chroma="420"; }
  local tgt_pix="yuv420p" profile="SDR"
  if [[ "$trc" == "arib-std-b67" || "$trc" == "hlg" ]]; then
    profile="HLG"; tgt_pix="yuv420p10le"; COLOR_ARGS=(-color_primaries bt2020 -color_trc arib-std-b67 -colorspace bt2020nc)
  elif [[ "$prim" == "bt2020" || "$cspace" == "bt2020nc" || "$trc" == "smpte2084" ]]; then
    profile="HDR10"; tgt_pix="yuv420p10le"; COLOR_ARGS=(-color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc)
  else
    profile="SDR"; tgt_pix=$([[ $is_10bit -eq 1 ]] && echo yuv420p10le || echo yuv420p)
    [[ -z "$prim" ]] && prim="bt709"; [[ -z "$trc" ]] && trc="bt709"; [[ -z "$cspace" ]] && cspace="bt709"
    COLOR_ARGS=(-color_primaries "$prim" -color_trc "$trc" -colorspace "$cspace")
  fi
  PROFILE_DESC="$profile"; TARGET_PIXFMT="$tgt_pix"
}

demux_to_annexb() {
  local src="$1" out="$2" need_annexb="$3"
  local vcodec; vcodec="$(_vcodec_name "$src")"; vcodec="$(printf %s "$vcodec" | tr '[:upper:]' '[:lower:]')"
  local fmt="" bsf=""
  if [[ "$vcodec" == "hevc" || "$vcodec" == "h265" ]]; then
    fmt="hevc"; bsf="hevc_mp4toannexb"
  elif [[ "$vcodec" == "h264" || "$vcodec" == "avc1" ]]; then
    fmt="h264"; bsf="h264_mp4toannexb"
  else
    warn "Unknown/unsupported video codec ($vcodec) for raw ES demux; skipping demux."
    : > "$out"
    return 0
  fi

  if (( DRY_RUN )); then
    local _annex_hint=""
    [[ "${need_annexb:-0}" -ne 0 ]] && _annex_hint=" (Annex-B)"
    say "DRY-RUN: demux raw $fmt${_annex_hint} → $out"
    return 0
  fi

  if [[ "$need_annexb" == "1" ]]; then
    ffmpeg $FFMPEG_FLAGS -i "$src" -map 0:v:0 -c copy -bsf:v "$bsf" -f "$fmt" "$out"
  else
    ffmpeg $FFMPEG_FLAGS -i "$src" -map 0:v:0 -c copy                 -f "$fmt" "$out"
  fi
}

# Improved DV detector (more robust than a single grep)
detect_dv() {
  (( DISABLE_DV )) && return 1
  # Fast checks on stream metadata
  if ffprobe $FFPROBE_FLAGS -show_streams -select_streams v:0 "$SRC_ABS" 2>/dev/null \
      | grep -qiE 'dolby_vision|dv_profile|dovi|dvhe|dvh1|com\.dolby\.vision'; then
    return 0
  fi
  # Fallback: scan a few frames for DOVI side data (can be slower)
  ffprobe $FFPROBE_FLAGS -show_frames -read_intervals %+#5 -select_streams v:0 "$SRC_ABS" 2>/dev/null \
    | grep -m1 -qiE 'DOVI|dolby' && return 0
  return 1
}

# ---------- Decide color + DV ----------
decide_color_and_pixfmt "$SRC_ABS"

if [[ "$PROFILE_DESC" != "HDR10" && "$PROFILE_DESC" != "HLG" ]]; then
  X265_PARAMS="${X265_PARAMS_BASE/:hdr-opt=1/}"
else
  X265_PARAMS="$X265_PARAMS_BASE"
fi
[[ -n "$LEVEL_VALUE" ]] && X265_PARAMS="${X265_PARAMS}:level-idc=${LEVEL_VALUE}"

IS_DV=0
if detect_dv; then
  IS_DV=1; note "Dolby Vision detected — extract → inject; convert only if injection fails."
else
  note "No Dolby Vision detected."
fi
(( DISABLE_DV )) && note "DV handling explicitly disabled via --no-dv."

# [1/15] Prepare ES / Annex-B
say "[1/15] Preparing raw elementary stream$([[ $IS_DV -eq 1 ]] && echo ' (Annex-B for DV)')…"
if (( IS_DV == 1 && DISABLE_DV == 0 )); then
  demux_to_annexb "$SRC_ABS" "$V_SRC_DV" 1; mark_done "Demux DV Annex-B → $(basename "$V_SRC_DV")"
else
  demux_to_annexb "$SRC_ABS" "$V_SRC_ES" 1; mark_done "Demux raw ES → $(basename "$V_SRC_ES")"
fi

# [2/15] Extract RPU
if (( IS_DV == 1 && DISABLE_DV == 0 )); then
  say "[2/15] Extracting Dolby Vision RPU → $RPU_P7"
  if dv_extract_rpu "$V_SRC_DV" "$RPU_P7"; then mark_done "Extract RPU"; else
    if (( ALLOW_DV_FALLBACK )); then warn "RPU extract failed; proceeding without DV."; IS_DV=0
    else die 20 "DV RPU extract failed. Set ALLOW_DV_FALLBACK=1 or pass --no-dv to continue without DV."; fi
  fi
fi

# [3/15] encode base first

# [4/15] Encode base video
say "[4/15] Encoding base video ($PROFILE_DESC, $TARGET_PIXFMT, preset $PRESET_VALUE, CRF $CRF_VALUE) → $V_BASE"
if (( DRY_RUN )); then
  say "DRY-RUN: x265 encode (CRF $CRF_VALUE, preset $PRESET_VALUE) → $V_BASE"
else
  # Build ffmpeg args, add -threads if provided
  ffargs=( $FFMPEG_FLAGS -i "$SRC_ABS" -map 0:v:0 -c:v libx265 -preset "$PRESET_VALUE" -crf "$CRF_VALUE" -pix_fmt "$TARGET_PIXFMT" )
  [[ -n "$THREADS" ]] && ffargs+=( -threads "$THREADS" )
  ffmpeg "${ffargs[@]}" -x265-params "$X265_PARAMS" "${COLOR_ARGS[@]}" -an "$V_BASE"
fi
mark_done "Encode base"

# [5/15] Inject DV (try pass-through first; convert only if needed)
say "[5/15] Finalizing video stream (DV inject if available) → $V_MIXED"
if (( IS_DV == 1 && DISABLE_DV == 0 )); then
  if dv_inject_with_rpu "$V_BASE" "$V_MIXED" "$RPU_P7"; then
    note "DV injection succeeded with extracted RPU (treated as P8.x)."; mark_done "DV inject (pass-through)"
  else
    note "Initial DV injection failed — attempting P7→P8.1 conversion of RPU."
    if dv_convert_p7_to_p81 "$RPU_P7" "$RPU_P81" && dv_inject_with_rpu "$V_BASE" "$V_MIXED" "$RPU_P81"; then
      note "RPU converted and injection succeeded (Profile 7 → P8.1)."; mark_done "DV convert+inject"
    else
      if (( ALLOW_DV_FALLBACK )); then warn "DV conversion/injection failed; using non-DV base video."; cp -f "$V_BASE" "$V_MIXED"; IS_DV=0
      else die 22 "DV conversion/injection failed. Set ALLOW_DV_FALLBACK=1 or pass --no-dv to continue without DV."; fi
    fi
  fi
else
  cp -f "$V_BASE" "$V_MIXED"; mark_done "Use base video (non-DV)"
fi

# [6/15] Audio presence
HAS_AUDIO=0; _has_stream "$SRC_ABS" audio && HAS_AUDIO=1

# [7) Decide audio temp names/formats]
AIDX=0
ACODEC="$(ffprobe $FFPROBE_FLAGS -select_streams a:0 -show_entries stream=codec_name -of default=nk=1:nw=1 "$SRC_ABS" || true)"
ACHANNELS="$(ffprobe $FFPROBE_FLAGS -select_streams a:0 -show_entries stream=channels   -of default=nk=1:nw=1 "$SRC_ABS" || true)"; [[ -z "$ACHANNELS" ]] && ACHANNELS=2
ADD_STEREO=0; [[ "$ACHANNELS" -gt 2 ]] && ADD_STEREO=1

A_PRIMARY_FMT=""
case "$ACODEC" in
  aac)   A_PRIMARY="$WORKDIR/audio_primary.m4a" ;;
  eac3)  A_PRIMARY="$WORKDIR/audio_primary.eac3"; A_PRIMARY_FMT="eac3" ;;
  ac3)   A_PRIMARY="$WORKDIR/audio_primary.ac3";  A_PRIMARY_FMT="ac3"  ;;
  *)     A_PRIMARY="$WORKDIR/audio_primary.m4a" ;;
esac
AAC_STEREO="$WORKDIR/stereo.m4a"

# [8/15] Prepare audio
if (( HAS_AUDIO )); then
  if (( PARALLEL_AUDIO )); then
    say "[8/15] Preparing primary audio (parallel mode) → $A_PRIMARY"
    if [[ "$ACODEC" == "eac3" || "$ACODEC" == "ac3" || "$ACODEC" == "aac" ]]; then
      if [[ "$ACODEC" == "aac" ]]; then ( ffmpeg $FFMPEG_FLAGS -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy -f mp4 "$A_PRIMARY" ) & PID_PRIMARY=$!
      else                                ( ffmpeg $FFMPEG_FLAGS -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy ${A_PRIMARY_FMT:+-f "$A_PRIMARY_FMT"} "$A_PRIMARY" ) & PID_PRIMARY=$!
      fi
      note "Direct Play codec detected ($ACODEC). Copying without conversion."
    else
      if (( ACHANNELS <= 2 )); then
        # keep per-job threads low in parallel mode unless user overrides
        if [[ -n "$THREADS" ]]; then ( ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY" ) & PID_PRIMARY=$!
        else                          ( ffmpeg $FFMPEG_FLAGS -threads 1         -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY" ) & PID_PRIMARY=$!
        fi
        note "Unsupported stereo codec ($ACODEC). Transcoding to AAC $STEREO_BITRATE."
      else
        channels_to_keep="$ACHANNELS"; (( channels_to_keep > 8 )) && channels_to_keep=8
        A_PRIMARY="$WORKDIR/audio_primary.eac3"; A_PRIMARY_FMT="eac3"
        if [[ -n "$THREADS" ]]; then ( ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a eac3 -b:a "$([[ $channels_to_keep -ge 7 ]] && echo 768k || echo 640k)" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY" ) & PID_PRIMARY=$!
        else                          ( ffmpeg $FFMPEG_FLAGS -threads 1         -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a eac3 -b:a "$([[ $channels_to_keep -ge 7 ]] && echo 768k || echo 640k)" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY" ) & PID_PRIMARY=$!
        fi
        note "Unsupported multichannel codec ($ACODEC). Transcoding to E-AC-3."
      fi
    fi
    if (( ADD_STEREO )); then
      say "[9/15] Creating AAC stereo fallback (parallel) → $AAC_STEREO"
      if [[ -n "$THREADS" ]]; then ( ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO" ) & PID_STEREO=$!
      else                          ( ffmpeg $FFMPEG_FLAGS -threads 1         -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO" ) & PID_STEREO=$!
      fi
    else
      : > "$AAC_STEREO"; PID_STEREO=""
    fi
    PRIMARY_STATUS=0; STEREO_STATUS=0
    [[ -n "${PID_PRIMARY:-}" ]] && { if ! wait "$PID_PRIMARY"; then PRIMARY_STATUS=$?; kill_if_running "$PID_STEREO"; fi; }
    [[ -n "${PID_STEREO:-}"  ]] && { if ! wait "$PID_STEREO";  then STEREO_STATUS=$?;  kill_if_running "$PID_PRIMARY"; fi; }
    (( PRIMARY_STATUS != 0 )) && die 30 "Primary audio job failed (exit $PRIMARY_STATUS)."
    (( ADD_STEREO == 1 && STEREO_STATUS != 0 )) && die 31 "Stereo fallback job failed (exit $STEREO_STATUS)."
    mark_done "Primary audio prepared (parallel)"; (( ADD_STEREO )) && mark_done "Create AAC stereo (parallel)"
  else
    say "[8/15] Preparing primary audio → $A_PRIMARY"
    if [[ "$ACODEC" == "eac3" || "$ACODEC" == "ac3" || "$ACODEC" == "aac" ]]; then
      if [[ "$ACODEC" == "aac" ]]; then ffmpeg $FFMPEG_FLAGS -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy -f mp4 "$A_PRIMARY"
      else                               ffmpeg $FFMPEG_FLAGS -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy ${A_PRIMARY_FMT:+-f "$A_PRIMARY_FMT"} "$A_PRIMARY"
      fi
      note "Direct Play codec detected ($ACODEC). Copying without conversion."
    else
      if (( ACHANNELS <= 2 )); then
        if [[ -n "$THREADS" ]]; then ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY"
        else                          ffmpeg $FFMPEG_FLAGS                    -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$A_PRIMARY"
        fi
        note "Unsupported stereo codec ($ACODEC). Transcoding to AAC $STEREO_BITRATE."
      else
        channels_to_keep="$ACHANNELS"; (( channels_to_keep > 8 )) && channels_to_keep=8
        A_PRIMARY="$WORKDIR/audio_primary.eac3"; A_PRIMARY_FMT="eac3"
        if [[ -n "$THREADS" ]]; then ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a eac3 -b:a "$([[ $channels_to_keep -ge 7 ]] && echo 768k || echo 640k)" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY"
        else                          ffmpeg $FFMPEG_FLAGS                    -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a eac3 -b:a "$([[ $channels_to_keep -ge 7 ]] && echo 768k || echo 640k)" -ac "$channels_to_keep" -f eac3 "$A_PRIMARY"
        fi
        note "Unsupported multichannel codec ($ACODEC). Transcoding to E-AC-3."
      fi
    fi
    mark_done "Primary audio prepared"
    if (( ADD_STEREO )); then
      say "[9/15] Creating AAC stereo fallback → $AAC_STEREO"
      if [[ -n "$THREADS" ]]; then ffmpeg $FFMPEG_FLAGS -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
      else                          ffmpeg $FFMPEG_FLAGS                    -i "$SRC_ABS" -map 0:a:"$AIDX" -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
      fi
      mark_done "Create AAC stereo"
    else
      note "[9/15] Primary audio is stereo; no extra stereo fallback needed."
      : > "$AAC_STEREO"
    fi
  fi
else
  : > "$A_PRIMARY"; : > "$AAC_STEREO"; note "No audio tracks detected; continuing with video-only."
fi

# [10/15] Mux primary MP4
say "[10/15] Muxing primary MP4 → $MP4_BASE"
if (( DRY_RUN )); then
  say "DRY-RUN: MP4Box mux → $MP4_BASE"
else
  if [[ -s "$A_PRIMARY" ]]; then MP4Box -quiet -add "$V_MIXED" -add "$A_PRIMARY" -inter 500 -new "$MP4_BASE"
  else                              MP4Box -quiet -add "$V_MIXED"               -inter 500 -new "$MP4_BASE"
  fi
fi
mark_done "Mux primary"

# [11/15] Assemble final
say "[11/15] Assembling final MP4 → $TMP_OUT"
if (( DRY_RUN )); then
  say "DRY-RUN: finalize → $TMP_OUT"
else
  if [[ -s "$AAC_STEREO" ]]; then MP4Box -quiet -add "$MP4_BASE" -add "$AAC_STEREO:name=Stereo:lang=eng" -inter 500 -new "$TMP_OUT"
  else cp -f "$MP4_BASE" "$TMP_OUT"
  fi
  [[ ! -s "$TMP_OUT" ]] && die 40 "Final temp output not created or empty: $TMP_OUT"
fi
mark_done "Finalize MP4"

# [12/15] DV note
if (( IS_DV == 1 && DISABLE_DV == 0 )); then note "Dolby Vision present in output (P8.1 injected or pass-through)."; else note "Output is non-DV (HDR10/HLG/SDR as applicable)."; fi

# [13/15] Verify
say "[13/15] Verifying streams…"
if (( DRY_RUN )); then
  say "DRY-RUN: ffprobe verify $TMP_OUT"
else
  ffprobe -hide_banner -show_streams "$TMP_OUT" | sed -n '1,160p' || true
fi
mark_done "Verify output"

# [14/15] Size
say "[14/15] Output (temp) size:"
if (( DRY_RUN )); then
  say "DRY-RUN: size of $TMP_OUT"
else
  filesize_pretty "$TMP_OUT"
fi

# [15/15] Move in EXIT trap
note "✅ Staging complete — will atomically move to: $OUT"